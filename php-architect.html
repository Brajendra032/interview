<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò PHP Architect Interview Guide - Full Stack Developer Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-container">
        <div class="nav-content">
            <a href="index.html" class="nav-brand">
                <i class="fas fa-code"></i>
                Interview Prep
            </a>
            <div class="nav-links">
                <a href="#architecture" class="nav-link">Architecture</a>
                <a href="#performance" class="nav-link">Performance</a>
                <a href="#security" class="nav-link">Security</a>
                <a href="#scalability" class="nav-link">Scalability</a>
                <a href="index.html" class="back-button">‚Üê Back</a>
            </div>
        </div>
    </nav>

    <div class="main-container">
        <!-- Hero Section -->
        <section class="hero-section">
            <div class="hero-content">
                <h1 class="hero-title">üêò PHP Architect Interview Guide</h1>
                <p class="hero-subtitle">
                    Master Advanced PHP Concepts, Architecture Patterns, and Enterprise Solutions
                </p>

                <div class="hero-stats">
                    <div class="stat-item">
                        <span class="stat-number">50+</span>
                        <span class="stat-label">Questions</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">25+</span>
                        <span class="stat-label">Code Examples</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">20+</span>
                        <span class="stat-label">Design Patterns</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number">100%</span>
                        <span class="stat-label">Architect Level</span>
                    </div>
                </div>
            </div>
        </section>

        <div class="content">
            <!-- Code Modal -->
            <div id="codeModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2 id="modalTitle" class="modal-title">Code Example</h2>
                        <button class="modal-close" onclick="closeCodeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div id="modalCode" class="code-modal-content" data-lang="php"></div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <i class="fas fa-building section-icon"></i>
                    <div>
                        <h2 class="section-title">üèóÔ∏è Advanced PHP Architecture & Design Patterns</h2>
                        <p class="section-description">Master enterprise-level PHP architecture, design patterns, and scalable solutions</p>
                    </div>
                </div>

                <div class="question-grid">
                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">1</div>
                            <h3 class="question-title">Service Container & Dependency Injection</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Architecture</span>
                            <span class="question-badge">DI</span>
                            <span class="question-badge">SOLID</span>
                        </div>
                        <div class="question-content">
                            <p>Design and implement a robust service container with dependency injection for complex PHP applications.</p>

                            <div class="highlight-box info">
                                <div class="highlight-header">
                                    <i class="fas fa-cubes highlight-icon"></i>
                                    <strong>Service Container Benefits:</strong>
                                </div>
                                <ul>
                                    <li><strong>Testability:</strong> Easy mocking and unit testing</li>
                                    <li><strong>Maintainability:</strong> Loose coupling between components</li>
                                    <li><strong>Flexibility:</strong> Runtime configuration and service swapping</li>
                                    <li><strong>Performance:</strong> Lazy loading and singleton management</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="Advanced Service Container Implementation">
<?php
/**
 * Advanced Service Container with Dependency Injection
 * Enterprise-grade IoC container with advanced features
 */

interface ContainerInterface
{
    public function get(string $id);
    public function has(string $id): bool;
    public function set(string $id, $concrete = null);
    public function singleton(string $id, $concrete = null);
    public function bind(string $id, $concrete = null, bool $shared = false);
    public function make(string $class, array $parameters = []);
}

class ServiceContainer implements ContainerInterface
{
    private array $bindings = [];
    private array $instances = [];
    private array $resolved = [];
    private array $aliases = [];
    private array $tags = [];
    private array $contextualBindings = [];

    public function __construct()
    {
        $this->registerCoreBindings();
    }

    private function registerCoreBindings(): void
    {
        $this->singleton(ContainerInterface::class, $this);
        $this->singleton('container', $this);
    }

    public function bind(string $id, $concrete = null, bool $shared = false): void
    {
        $this->dropStaleInstances($id);

        if ($concrete === null) {
            $concrete = $id;
        }

        $this->bindings[$id] = [
            'concrete' => $this->getClosure($id, $concrete),
            'shared' => $shared
        ];
    }

    public function singleton(string $id, $concrete = null): void
    {
        $this->bind($id, $concrete, true);
    }

    public function set(string $id, $concrete = null): void
    {
        $this->dropStaleInstances($id);

        if ($concrete === null) {
            $concrete = $id;
        }

        $this->instances[$id] = $concrete;
    }

    public function has(string $id): bool
    {
        return isset($this->bindings[$id]) ||
               isset($this->instances[$id]) ||
               isset($this->aliases[$id]);
    }

    public function get(string $id)
    {
        return $this->resolve($id);
    }

    public function make(string $class, array $parameters = [])
    {
        return $this->build($class, $parameters);
    }

    private function resolve(string $id)
    {
        $id = $this->getAlias($id);

        // Check for contextual binding
        $id = $this->getContextualConcrete($id);

        if (isset($this->instances[$id])) {
            return $this->instances[$id];
        }

        if (isset($this->bindings[$id])) {
            return $this->buildBinding($id);
        }

        // Auto-resolve concrete classes
        if (class_exists($id)) {
            return $this->build($id);
        }

        throw new Exception("Unable to resolve dependency [{$id}]");
    }

    private function buildBinding(string $id): mixed
    {
        $binding = $this->bindings[$id];

        if ($binding['shared'] && isset($this->instances[$id])) {
            return $this->instances[$id];
        }

        $object = $this->call($binding['concrete']);

        if ($binding['shared']) {
            $this->instances[$id] = $object;
        }

        return $object;
    }

    private function build(string $concrete, array $parameters = [])
    {
        if ($concrete instanceof Closure) {
            return $this->call($concrete, $parameters);
        }

        $reflector = new ReflectionClass($concrete);

        if (!$reflector->isInstantiable()) {
            throw new Exception("Class {$concrete} is not instantiable");
        }

        $constructor = $reflector->getConstructor();

        if ($constructor === null) {
            return new $concrete;
        }

        $dependencies = $this->resolveDependencies(
            $constructor->getParameters(),
            $parameters
        );

        return $reflector->newInstanceArgs($dependencies);
    }

    private function resolveDependencies(array $parameters, array $primitives = []): array
    {
        $dependencies = [];

        foreach ($parameters as $parameter) {
            $dependency = $parameter->getType();

            if ($dependency === null) {
                if (array_key_exists($parameter->getName(), $primitives)) {
                    $dependencies[] = $primitives[$parameter->getName()];
                } elseif ($parameter->isDefaultValueAvailable()) {
                    $dependencies[] = $parameter->getDefaultValue();
                } else {
                    throw new Exception("Cannot resolve parameter \${$parameter->getName()}");
                }
            } elseif ($dependency instanceof ReflectionNamedType && !$dependency->isBuiltin()) {
                $dependencies[] = $this->resolve($dependency->getName());
            } elseif (array_key_exists($parameter->getName(), $primitives)) {
                $dependencies[] = $primitives[$parameter->getName()];
            } elseif ($parameter->isDefaultValueAvailable()) {
                $dependencies[] = $parameter->getDefaultValue();
            } else {
                throw new Exception("Cannot resolve parameter \${$parameter->getName()}");
            }
        }

        return $dependencies;
    }

    private function call(callable $callback, array $parameters = [])
    {
        if ($callback instanceof Closure) {
            return $callback($this, ...$parameters);
        }

        return call_user_func_array($callback, $parameters);
    }

    private function getClosure(string $id, $concrete): callable
    {
        return function ($container, $parameters = []) use ($id, $concrete) {
            if ($concrete instanceof Closure) {
                return $concrete($container, $parameters);
            }

            return $container->build($concrete, $parameters);
        };
    }

    private function dropStaleInstances(string $id): void
    {
        unset($this->instances[$id], $this->aliases[$id]);
    }

    public function alias(string $alias, string $id): void
    {
        $this->aliases[$alias] = $id;
    }

    private function getAlias(string $id): string
    {
        return $this->aliases[$id] ?? $id;
    }

    public function tag(array $ids, string $tag): void
    {
        foreach ($ids as $id) {
            $this->tags[$tag][] = $id;
        }
    }

    public function tagged(string $tag): array
    {
        $results = [];

        if (isset($this->tags[$tag])) {
            foreach ($this->tags[$tag] as $id) {
                $results[] = $this->get($id);
            }
        }

        return $results;
    }

    public function when(string $concrete): ContextualBindingBuilder
    {
        return new ContextualBindingBuilder($this, $concrete);
    }

    public function addContextualBinding(string $concrete, string $abstract, $implementation): void
    {
        $this->contextualBindings[$concrete][$abstract] = $implementation;
    }

    private function getContextualConcrete(string $id): string
    {
        // This would be more complex in a full implementation
        // tracking the current resolution context
        return $id;
    }

    public function flush(): void
    {
        $this->bindings = [];
        $this->instances = [];
        $this->resolved = [];
        $this->aliases = [];
        $this->tags = [];
        $this->contextualBindings = [];
        $this->registerCoreBindings();
    }
}

class ContextualBindingBuilder
{
    private ServiceContainer $container;
    private string $concrete;

    public function __construct(ServiceContainer $container, string $concrete)
    {
        $this->container = $container;
        $this->concrete = $concrete;
    }

    public function needs(string $abstract): ContextualBindingBuilder
    {
        $this->abstract = $abstract;
        return $this;
    }

    public function give($implementation): void
    {
        $this->container->addContextualBinding(
            $this->concrete,
            $this->abstract,
            $implementation
        );
    }
}

// Advanced Service Providers
abstract class ServiceProvider
{
    protected ServiceContainer $container;

    public function __construct(ServiceContainer $container)
    {
        $this->container = $container;
    }

    abstract public function register(): void;

    public function boot(): void
    {
        // Optional boot method for deferred setup
    }

    protected function bind(string $id, $concrete = null, bool $shared = false): void
    {
        $this->container->bind($id, $concrete, $shared);
    }

    protected function singleton(string $id, $concrete = null): void
    {
        $this->container->singleton($id, $concrete);
    }
}

class DatabaseServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->container->singleton(PDO::class, function ($container) {
            $config = $container->get('config.database');

            return new PDO(
                "mysql:host={$config['host']};dbname={$config['database']}",
                $config['username'],
                $config['password'],
                [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                    PDO::ATTR_EMULATE_PREPARES => false,
                ]
            );
        });

        $this->container->singleton('db.connection', PDO::class);
    }
}

class CacheServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->container->singleton('cache.store', function ($container) {
            $config = $container->get('config.cache');
            $driver = $config['driver'] ?? 'file';

            switch ($driver) {
                case 'redis':
                    return new RedisCache($config['redis']);
                case 'memcached':
                    return new MemcachedCache($config['memcached']);
                default:
                    return new FileCache($config['file']);
            }
        });
    }
}

// Usage Example
$container = new ServiceContainer();

// Register service providers
$container->singleton('config', [
    'database' => [
        'host' => 'localhost',
        'database' => 'myapp',
        'username' => 'root',
        'password' => 'secret'
    ],
    'cache' => [
        'driver' => 'redis',
        'redis' => ['host' => 'localhost', 'port' => 6379]
    ]
]);

// Register providers
$databaseProvider = new DatabaseServiceProvider($container);
$cacheProvider = new CacheServiceProvider($container);

$databaseProvider->register();
$cacheProvider->register();

// Bind services
$container->singleton('user.repository', UserRepository::class);
$container->bind('user.service', UserService::class);

// Resolve services
$userService = $container->get('user.service');
$user = $userService->findUserById(123);

// Tagged services example
$container->tag(['email.mailer', 'sms.mailer', 'push.mailer'], 'notification');
$notifiers = $container->tagged('notification');

// Contextual binding
$container->when(ReportGenerator::class)
          ->needs(MailerInterface::class)
          ->give(TransactionalMailer::class);

$reportGenerator = $container->make(ReportGenerator::class);
?>
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">2</div>
                            <h3 class="question-title">Repository Pattern & Data Access Layer</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Patterns</span>
                            <span class="question-badge">Data Access</span>
                            <span class="question-badge">SOLID</span>
                        </div>
                        <div class="question-content">
                            <p>Implement the Repository pattern with specifications, criteria, and advanced querying capabilities.</p>

                            <div class="highlight-box success">
                                <div class="highlight-header">
                                    <i class="fas fa-database highlight-icon"></i>
                                    <strong>Repository Pattern Benefits:</strong>
                                </div>
                                <ul>
                                    <li><strong>Separation of Concerns:</strong> Data access logic isolated from business logic</li>
                                    <li><strong>Testability:</strong> Easy mocking of data access layer</li>
                                    <li><strong>Maintainability:</strong> Centralized data access patterns</li>
                                    <li><strong>Flexibility:</strong> Support for multiple data sources</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="Repository Pattern with Criteria & Specifications">
// Repository Pattern with Criteria and Specifications
// Advanced data access layer implementation

interface RepositoryInterface
{
    public function find($id);
    public function findAll();
    public function findBy(array $criteria);
    public function findOneBy(array $criteria);
    public function save($entity): void;
    public function delete($entity): void;
    public function getQueryBuilder(): QueryBuilder;
    public function matching(Criteria $criteria);
}

interface SpecificationInterface
{
    public function isSatisfiedBy($candidate): bool;
    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder;
}

abstract class AbstractSpecification implements SpecificationInterface
{
    public function and(SpecificationInterface $spec): AndSpecification
    {
        return new AndSpecification($this, $spec);
    }

    public function or(SpecificationInterface $spec): OrSpecification
    {
        return new OrSpecification($this, $spec);
    }

    public function not(): NotSpecification
    {
        return new NotSpecification($this);
    }
}

class AndSpecification extends AbstractSpecification
{
    private SpecificationInterface $left;
    private SpecificationInterface $right;

    public function __construct(SpecificationInterface $left, SpecificationInterface $right)
    {
        $this->left = $left;
        $this->right = $right;
    }

    public function isSatisfiedBy($candidate): bool
    {
        return $this->left->isSatisfiedBy($candidate) && $this->right->isSatisfiedBy($candidate);
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->andWhere($this->left->asQueryBuilder(new QueryBuilder()))
                  ->andWhere($this->right->asQueryBuilder(new QueryBuilder()));
    }
}

class OrSpecification extends AbstractSpecification
{
    private SpecificationInterface $left;
    private SpecificationInterface $right;

    public function __construct(SpecificationInterface $left, SpecificationInterface $right)
    {
        $this->left = $left;
        $this->right = $right;
    }

    public function isSatisfiedBy($candidate): bool
    {
        return $this->left->isSatisfiedBy($candidate) || $this->right->isSatisfiedBy($candidate);
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->orWhere($this->left->asQueryBuilder(new QueryBuilder()))
                  ->orWhere($this->right->asQueryBuilder(new QueryBuilder()));
    }
}

class NotSpecification extends AbstractSpecification
{
    private SpecificationInterface $spec;

    public function __construct(SpecificationInterface $spec)
    {
        $this->spec = $spec;
    }

    public function isSatisfiedBy($candidate): bool
    {
        return !$this->spec->isSatisfiedBy($candidate);
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->andWhere('NOT (' . $this->spec->asQueryBuilder(new QueryBuilder())->getSQL() . ')');
    }
}

class Criteria
{
    private array $where = [];
    private array $orderBy = [];
    private ?int $limit = null;
    private ?int $offset = null;
    private array $joins = [];

    public static function create(): self
    {
        return new self();
    }

    public function where(string $field, $value, string $operator = '='): self
    {
        $this->where[] = [$field, $operator, $value];
        return $this;
    }

    public function orderBy(string $field, string $direction = 'ASC'): self
    {
        $this->orderBy[$field] = $direction;
        return $this;
    }

    public function limit(int $limit): self
    {
        $this->limit = $limit;
        return $this;
    }

    public function offset(int $offset): self
    {
        $this->offset = $offset;
        return $this;
    }

    public function join(string $table, string $condition): self
    {
        $this->joins[] = [$table, $condition];
        return $this;
    }

    public function getWhere(): array
    {
        return $this->where;
    }

    public function getOrderBy(): array
    {
        return $this->orderBy;
    }

    public function getLimit(): ?int
    {
        return $this->limit;
    }

    public function getOffset(): ?int
    {
        return $this->offset;
    }

    public function getJoins(): array
    {
        return $this->joins;
    }
}

class QueryBuilder
{
    private string $table;
    private array $select = ['*'];
    private array $where = [];
    private array $joins = [];
    private array $orderBy = [];
    private ?int $limit = null;
    private ?int $offset = null;
    private array $parameters = [];

    public function __construct(string $table = '')
    {
        $this->table = $table;
    }

    public function select(array $columns): self
    {
        $this->select = $columns;
        return $this;
    }

    public function from(string $table): self
    {
        $this->table = $table;
        return $this;
    }

    public function where(string $condition, $parameter = null): self
    {
        $this->where[] = $condition;
        if ($parameter !== null) {
            $this->parameters[] = $parameter;
        }
        return $this;
    }

    public function andWhere(string $condition, $parameter = null): self
    {
        return $this->where($condition, $parameter);
    }

    public function orWhere(string $condition, $parameter = null): self
    {
        $lastIndex = count($this->where) - 1;
        if ($lastIndex >= 0) {
            $this->where[$lastIndex] = '(' . $this->where[$lastIndex] . ' OR ' . $condition . ')';
        } else {
            $this->where[] = $condition;
        }
        if ($parameter !== null) {
            $this->parameters[] = $parameter;
        }
        return $this;
    }

    public function join(string $table, string $condition): self
    {
        $this->joins[] = "JOIN {$table} ON {$condition}";
        return $this;
    }

    public function leftJoin(string $table, string $condition): self
    {
        $this->joins[] = "LEFT JOIN {$table} ON {$condition}";
        return $this;
    }

    public function orderBy(string $column, string $direction = 'ASC'): self
    {
        $this->orderBy[] = "{$column} {$direction}";
        return $this;
    }

    public function limit(int $limit): self
    {
        $this->limit = $limit;
        return $this;
    }

    public function offset(int $offset): self
    {
        $this->offset = $offset;
        return $this;
    }

    public function setParameter(string $key, $value): self
    {
        $this->parameters[$key] = $value;
        return $this;
    }

    public function getSQL(): string
    {
        $sql = 'SELECT ' . implode(', ', $this->select);
        $sql .= ' FROM ' . $this->table;

        if (!empty($this->joins)) {
            $sql .= ' ' . implode(' ', $this->joins);
        }

        if (!empty($this->where)) {
            $sql .= ' WHERE ' . implode(' AND ', $this->where);
        }

        if (!empty($this->orderBy)) {
            $sql .= ' ORDER BY ' . implode(', ', $this->orderBy);
        }

        if ($this->limit !== null) {
            $sql .= ' LIMIT ' . $this->limit;
        }

        if ($this->offset !== null) {
            $sql .= ' OFFSET ' . $this->offset;
        }

        return $sql;
    }

    public function getParameters(): array
    {
        return $this->parameters;
    }
}

abstract class AbstractRepository implements RepositoryInterface
{
    protected PDO $pdo;
    protected string $table;
    protected string $entityClass;

    public function __construct(PDO $pdo, string $table, string $entityClass)
    {
        $this->pdo = $pdo;
        $this->table = $table;
        $this->entityClass = $entityClass;
    }

    public function find($id)
    {
        $stmt = $this->pdo->prepare("SELECT * FROM {$this->table} WHERE id = ?");
        $stmt->execute([$id]);
        $data = $stmt->fetch(PDO::FETCH_ASSOC);

        return $data ? $this->hydrate($data) : null;
    }

    public function findAll(): array
    {
        $stmt = $this->pdo->query("SELECT * FROM {$this->table}");
        $data = $stmt->fetchAll(PDO::FETCH_ASSOC);

        return array_map([$this, 'hydrate'], $data);
    }

    public function findBy(array $criteria): array
    {
        $qb = $this->getQueryBuilder();

        foreach ($criteria as $field => $value) {
            if (is_array($value)) {
                $qb->where("{$field} IN (" . str_repeat('?,', count($value) - 1) . "?)", $value);
            } else {
                $qb->where("{$field} = ?", $value);
            }
        }

        return $this->executeQuery($qb);
    }

    public function findOneBy(array $criteria)
    {
        $results = $this->findBy($criteria);
        return $results[0] ?? null;
    }

    public function save($entity): void
    {
        $data = $this->extract($entity);

        if (isset($data['id']) && $data['id']) {
            $this->update($data);
        } else {
            $this->insert($data);
        }
    }

    public function delete($entity): void
    {
        $data = $this->extract($entity);
        $stmt = $this->pdo->prepare("DELETE FROM {$this->table} WHERE id = ?");
        $stmt->execute([$data['id']]);
    }

    public function getQueryBuilder(): QueryBuilder
    {
        return new QueryBuilder($this->table);
    }

    public function matching(Criteria $criteria): array
    {
        $qb = $this->getQueryBuilder();

        // Apply where conditions
        foreach ($criteria->getWhere() as [$field, $operator, $value]) {
            $qb->where("{$field} {$operator} ?", $value);
        }

        // Apply joins
        foreach ($criteria->getJoins() as [$table, $condition]) {
            $qb->join($table, $condition);
        }

        // Apply ordering
        foreach ($criteria->getOrderBy() as $field => $direction) {
            $qb->orderBy($field, $direction);
        }

        // Apply limit and offset
        if ($criteria->getLimit()) {
            $qb->limit($criteria->getLimit());
        }
        if ($criteria->getOffset()) {
            $qb->offset($criteria->getOffset());
        }

        return $this->executeQuery($qb);
    }

    protected function insert(array $data): void
    {
        unset($data['id']);
        $columns = array_keys($data);
        $placeholders = str_repeat('?,', count($columns) - 1) . '?';

        $sql = "INSERT INTO {$this->table} (" . implode(',', $columns) . ") VALUES ({$placeholders})";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute(array_values($data));
    }

    protected function update(array $data): void
    {
        $id = $data['id'];
        unset($data['id']);

        $set = [];
        foreach (array_keys($data) as $column) {
            $set[] = "{$column} = ?";
        }

        $sql = "UPDATE {$this->table} SET " . implode(', ', $set) . " WHERE id = ?";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute(array_merge(array_values($data), [$id]));
    }

    protected function executeQuery(QueryBuilder $qb): array
    {
        $stmt = $this->pdo->prepare($qb->getSQL());
        $stmt->execute($qb->getParameters());
        $data = $stmt->fetchAll(PDO::FETCH_ASSOC);

        return array_map([$this, 'hydrate'], $data);
    }

    abstract protected function hydrate(array $data);
    abstract protected function extract($entity): array;
}

// Concrete Repository Implementation
class UserRepository extends AbstractRepository
{
    public function __construct(PDO $pdo)
    {
        parent::__construct($pdo, 'users', User::class);
    }

    protected function hydrate(array $data)
    {
        $user = new User();
        $user->setId($data['id']);
        $user->setEmail($data['email']);
        $user->setName($data['name']);
        $user->setCreatedAt(new DateTime($data['created_at']));
        $user->setUpdatedAt(new DateTime($data['updated_at']));

        return $user;
    }

    protected function extract($entity): array
    {
        return [
            'id' => $entity->getId(),
            'email' => $entity->getEmail(),
            'name' => $entity->getName(),
            'created_at' => $entity->getCreatedAt()->format('Y-m-d H:i:s'),
            'updated_at' => $entity->getUpdatedAt()->format('Y-m-d H:i:s')
        ];
    }

    // Custom methods
    public function findActiveUsers(): array
    {
        return $this->findBy(['status' => 'active']);
    }

    public function findUsersByName(string $name): array
    {
        $qb = $this->getQueryBuilder();
        $qb->where('name LIKE ?', "%{$name}%")
           ->orderBy('name');

        return $this->executeQuery($qb);
    }

    public function findUsersWithPosts(): array
    {
        $qb = $this->getQueryBuilder();
        $qb->select(['u.*', 'COUNT(p.id) as post_count'])
           ->join('posts p', 'u.id = p.user_id')
           ->where('p.status = ?', 'published')
           ->orderBy('post_count', 'DESC')
           ->groupBy('u.id');

        // Note: This would need custom handling for the hydrate method
        // since we're selecting additional fields
        return $this->executeQuery($qb);
    }
}

// Specification Implementations
class ActiveUserSpecification extends AbstractSpecification
{
    public function isSatisfiedBy($candidate): bool
    {
        return $candidate instanceof User && $candidate->isActive();
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->where('status = ?', 'active');
    }
}

class PremiumUserSpecification extends AbstractSpecification
{
    public function isSatisfiedBy($candidate): bool
    {
        return $candidate instanceof User && $candidate->isPremium();
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->where('subscription_type = ?', 'premium');
    }
}

class RecentUserSpecification extends AbstractSpecification
{
    private DateTime $since;

    public function __construct(DateTime $since)
    {
        $this->since = $since;
    }

    public function isSatisfiedBy($candidate): bool
    {
        return $candidate instanceof User &&
               $candidate->getCreatedAt() >= $this->since;
    }

    public function asQueryBuilder(QueryBuilder $qb): QueryBuilder
    {
        return $qb->where('created_at >= ?', $this->since->format('Y-m-d H:i:s'));
    }
}

// Usage Examples
$userRepository = new UserRepository($pdo);

// Basic CRUD operations
$user = $userRepository->find(1);
$users = $userRepository->findAll();
$userRepository->save($newUser);
$userRepository->delete($user);

// Using Criteria
$criteria = Criteria::create()
    ->where('status', 'active')
    ->where('subscription_type', 'premium')
    ->orderBy('created_at', 'DESC')
    ->limit(10);

$premiumUsers = $userRepository->matching($criteria);

// Using Specifications
$activeSpec = new ActiveUserSpecification();
$premiumSpec = new PremiumUserSpecification();
$recentSpec = new RecentUserSpecification(new DateTime('-30 days'));

// Combine specifications
$complexSpec = $activeSpec->and($premiumSpec)->and($recentSpec);

// Find users matching specification
$qb = $userRepository->getQueryBuilder();
$query = $complexSpec->asQueryBuilder($qb);
$matchingUsers = $userRepository->executeQuery($query);

// Custom repository methods
$activeUsers = $userRepository->findActiveUsers();
$usersWithName = $userRepository->findUsersByName('John');
$usersWithPosts = $userRepository->findUsersWithPosts();
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">3</div>
                            <h3 class="question-title">Event Sourcing & CQRS Implementation</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Architecture</span>
                            <span class="question-badge">CQRS</span>
                            <span class="question-badge">Events</span>
                        </div>
                        <div class="question-content">
                            <p>Implement Event Sourcing and CQRS patterns for complex domain logic and audit trails.</p>

                            <div class="highlight-box warning">
                                <div class="highlight-header">
                                    <i class="fas fa-history highlight-icon"></i>
                                    <strong>Event Sourcing Benefits:</strong>
                                </div>
                                <ul>
                                    <li><strong>Audit Trail:</strong> Complete history of all changes</li>
                                    <strong>Temporal Queries:</strong> State at any point in time</li>
                                    <strong>Performance:</strong> Optimized read and write models</li>
                                    <strong>Scalability:</strong> Independent scaling of read/write workloads</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="Event Sourcing & CQRS Implementation">
// Event Sourcing & CQRS Implementation
// Complete domain-driven design with event sourcing

interface DomainEventInterface
{
    public function getAggregateId(): string;
    public function getEventType(): string;
    public function getOccurredAt(): DateTimeImmutable;
    public function getEventData(): array;
    public function getEventVersion(): int;
}

abstract class DomainEvent implements DomainEventInterface
{
    protected string $aggregateId;
    protected DateTimeImmutable $occurredAt;
    protected array $eventData;
    protected int $eventVersion;

    public function __construct(string $aggregateId, array $eventData = [])
    {
        $this->aggregateId = $aggregateId;
        $this->occurredAt = new DateTimeImmutable();
        $this->eventData = $eventData;
        $this->eventVersion = 1;
    }

    public function getAggregateId(): string
    {
        return $this->aggregateId;
    }

    public function getEventType(): string
    {
        return static::class;
    }

    public function getOccurredAt(): DateTimeImmutable
    {
        return $this->occurredAt;
    }

    public function getEventData(): array
    {
        return $this->eventData;
    }

    public function getEventVersion(): int
    {
        return $this->eventVersion;
    }

    public function withVersion(int $version): self
    {
        $this->eventVersion = $version;
        return $this;
    }
}

// Specific Domain Events
class UserRegistered extends DomainEvent
{
    public function __construct(string $userId, string $email, string $name)
    {
        parent::__construct($userId, [
            'email' => $email,
            'name' => $name
        ]);
    }
}

class UserEmailChanged extends DomainEvent
{
    public function __construct(string $userId, string $oldEmail, string $newEmail)
    {
        parent::__construct($userId, [
            'oldEmail' => $oldEmail,
            'newEmail' => $newEmail
        ]);
    }
}

class UserActivated extends DomainEvent
{
    public function __construct(string $userId)
    {
        parent::__construct($userId);
    }
}

class UserDeactivated extends DomainEvent
{
    public function __construct(string $userId)
    {
        parent::__construct($userId);
    }
}

// Aggregate Root
abstract class AggregateRoot
{
    protected string $id;
    protected array $domainEvents = [];
    protected int $version = 0;

    public function getId(): string
    {
        return $this->id;
    }

    public function getVersion(): int
    {
        return $this->version;
    }

    protected function recordEvent(DomainEventInterface $event): void
    {
        $this->domainEvents[] = $event->withVersion($this->version + 1);
        $this->apply($event);
        $this->version++;
    }

    public function releaseEvents(): array
    {
        $events = $this->domainEvents;
        $this->domainEvents = [];
        return $events;
    }

    abstract protected function apply(DomainEventInterface $event): void;
}

// User Aggregate
class User extends AggregateRoot
{
    private string $email;
    private string $name;
    private bool $isActive = false;
    private DateTimeImmutable $createdAt;

    public static function register(string $userId, string $email, string $name): self
    {
        $user = new self();
        $user->id = $userId;
        $user->recordEvent(new UserRegistered($userId, $email, $name));
        return $user;
    }

    public static function reconstituteFromEvents(array $events): self
    {
        $user = new self();

        foreach ($events as $event) {
            $user->apply($event);
            $user->version = $event->getEventVersion();
        }

        return $user;
    }

    public function changeEmail(string $newEmail): void
    {
        if ($this->email === $newEmail) {
            throw new DomainException('New email must be different from current email');
        }

        $this->recordEvent(new UserEmailChanged($this->id, $this->email, $newEmail));
    }

    public function activate(): void
    {
        if ($this->isActive) {
            throw new DomainException('User is already active');
        }

        $this->recordEvent(new UserActivated($this->id));
    }

    public function deactivate(): void
    {
        if (!$this->isActive) {
            throw new DomainException('User is already inactive');
        }

        $this->recordEvent(new UserDeactivated($this->id));
    }

    protected function apply(DomainEventInterface $event): void
    {
        switch (get_class($event)) {
            case UserRegistered::class:
                $this->email = $event->getEventData()['email'];
                $this->name = $event->getEventData()['name'];
                $this->createdAt = $event->getOccurredAt();
                break;

            case UserEmailChanged::class:
                $this->email = $event->getEventData()['newEmail'];
                break;

            case UserActivated::class:
                $this->isActive = true;
                break;

            case UserDeactivated::class:
                $this->isActive = false;
                break;
        }
    }

    // Read-only getters
    public function getEmail(): string
    {
        return $this->email;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function isActive(): bool
    {
        return $this->isActive;
    }

    public function getCreatedAt(): DateTimeImmutable
    {
        return $this->createdAt;
    }
}

// Event Store Interface
interface EventStoreInterface
{
    public function saveEvents(string $aggregateId, array $events): void;
    public function getEvents(string $aggregateId): array;
    public function getEventsFromVersion(string $aggregateId, int $version): array;
    public function getAllEvents(): array;
}

// Event Store Implementation
class PDOEventStore implements EventStoreInterface
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->createSchema();
    }

    private function createSchema(): void
    {
        $this->pdo->exec("
            CREATE TABLE IF NOT EXISTS event_store (
                id BIGINT PRIMARY KEY AUTO_INCREMENT,
                aggregate_id VARCHAR(255) NOT NULL,
                event_type VARCHAR(255) NOT NULL,
                event_data JSON NOT NULL,
                event_version INT NOT NULL,
                occurred_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_aggregate_id (aggregate_id),
                INDEX idx_event_type (event_type),
                INDEX idx_occurred_at (occurred_at)
            )
        ");
    }

    public function saveEvents(string $aggregateId, array $events): void
    {
        $this->pdo->beginTransaction();

        try {
            foreach ($events as $event) {
                $stmt = $this->pdo->prepare("
                    INSERT INTO event_store
                    (aggregate_id, event_type, event_data, event_version, occurred_at)
                    VALUES (?, ?, ?, ?, ?)
                ");

                $stmt->execute([
                    $aggregateId,
                    $event->getEventType(),
                    json_encode($event->getEventData()),
                    $event->getEventVersion(),
                    $event->getOccurredAt()->format('Y-m-d H:i:s')
                ]);
            }

            $this->pdo->commit();
        } catch (Exception $e) {
            $this->pdo->rollBack();
            throw $e;
        }
    }

    public function getEvents(string $aggregateId): array
    {
        $stmt = $this->pdo->prepare("
            SELECT * FROM event_store
            WHERE aggregate_id = ?
            ORDER BY event_version ASC
        ");
        $stmt->execute([$aggregateId]);

        return array_map([$this, 'hydrateEvent'], $stmt->fetchAll(PDO::FETCH_ASSOC));
    }

    public function getEventsFromVersion(string $aggregateId, int $version): array
    {
        $stmt = $this->pdo->prepare("
            SELECT * FROM event_store
            WHERE aggregate_id = ? AND event_version > ?
            ORDER BY event_version ASC
        ");
        $stmt->execute([$aggregateId, $version]);

        return array_map([$this, 'hydrateEvent'], $stmt->fetchAll(PDO::FETCH_ASSOC));
    }

    public function getAllEvents(): array
    {
        $stmt = $this->pdo->query("
            SELECT * FROM event_store
            ORDER BY occurred_at ASC
        ");

        return array_map([$this, 'hydrateEvent'], $stmt->fetchAll(PDO::FETCH_ASSOC));
    }

    private function hydrateEvent(array $data): DomainEventInterface
    {
        $eventClass = $data['event_type'];
        $eventData = json_decode($data['event_data'], true);

        $event = new $eventClass($data['aggregate_id'], $eventData);
        $event = $event->withVersion($data['event_version']);

        // Set the occurred at time from stored data
        $reflection = new ReflectionClass($event);
        $property = $reflection->getProperty('occurredAt');
        $property->setAccessible(true);
        $property->setValue($event, new DateTimeImmutable($data['occurred_at']));

        return $event;
    }
}

// Command Handler
class CommandHandler
{
    private EventStoreInterface $eventStore;

    public function __construct(EventStoreInterface $eventStore)
    {
        $this->eventStore = $eventStore;
    }

    public function handle($command): void
    {
        switch (get_class($command)) {
            case RegisterUserCommand::class:
                $this->handleRegisterUser($command);
                break;
            case ChangeUserEmailCommand::class:
                $this->handleChangeUserEmail($command);
                break;
            case ActivateUserCommand::class:
                $this->handleActivateUser($command);
                break;
        }
    }

    private function handleRegisterUser(RegisterUserCommand $command): void
    {
        $user = User::register($command->getUserId(), $command->getEmail(), $command->getName());
        $this->eventStore->saveEvents($user->getId(), $user->releaseEvents());
    }

    private function handleChangeUserEmail(ChangeUserEmailCommand $command): void
    {
        $events = $this->eventStore->getEvents($command->getUserId());
        $user = User::reconstituteFromEvents($events);

        $user->changeEmail($command->getNewEmail());

        $this->eventStore->saveEvents($user->getId(), $user->releaseEvents());
    }

    private function handleActivateUser(ActivateUserCommand $command): void
    {
        $events = $this->eventStore->getEvents($command->getUserId());
        $user = User::reconstituteFromEvents($events);

        $user->activate();

        $this->eventStore->saveEvents($user->getId(), $user->releaseEvents());
    }
}

// Read Model (CQRS)
class UserReadModel
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->createReadModel();
    }

    private function createReadModel(): void
    {
        $this->pdo->exec("
            CREATE TABLE IF NOT EXISTS user_read_model (
                id VARCHAR(255) PRIMARY KEY,
                email VARCHAR(255) UNIQUE NOT NULL,
                name VARCHAR(255) NOT NULL,
                is_active BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            )
        ");
    }

    public function updateFromEvent(DomainEventInterface $event): void
    {
        switch (get_class($event)) {
            case UserRegistered::class:
                $this->insertUser($event);
                break;
            case UserEmailChanged::class:
                $this->updateUserEmail($event);
                break;
            case UserActivated::class:
            case UserDeactivated::class:
                $this->updateUserStatus($event);
                break;
        }
    }

    private function insertUser(UserRegistered $event): void
    {
        $stmt = $this->pdo->prepare("
            INSERT INTO user_read_model (id, email, name, created_at)
            VALUES (?, ?, ?, ?)
        ");
        $stmt->execute([
            $event->getAggregateId(),
            $event->getEventData()['email'],
            $event->getEventData()['name'],
            $event->getOccurredAt()->format('Y-m-d H:i:s')
        ]);
    }

    private function updateUserEmail(UserEmailChanged $event): void
    {
        $stmt = $this->pdo->prepare("
            UPDATE user_read_model
            SET email = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ");
        $stmt->execute([
            $event->getEventData()['newEmail'],
            $event->getAggregateId()
        ]);
    }

    private function updateUserStatus(DomainEventInterface $event): void
    {
        $isActive = $event instanceof UserActivated;
        $stmt = $this->pdo->prepare("
            UPDATE user_read_model
            SET is_active = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ");
        $stmt->execute([$isActive, $event->getAggregateId()]);
    }

    public function findUserById(string $id): ?array
    {
        $stmt = $this->pdo->prepare("SELECT * FROM user_read_model WHERE id = ?");
        $stmt->execute([$id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }

    public function findAllUsers(): array
    {
        $stmt = $this->pdo->query("SELECT * FROM user_read_model ORDER BY created_at DESC");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

// Event Projector
class EventProjector
{
    private array $projectors = [];

    public function register(string $eventType, callable $projector): void
    {
        $this->projectors[$eventType][] = $projector;
    }

    public function project(DomainEventInterface $event): void
    {
        $eventType = $event->getEventType();

        if (isset($this->projectors[$eventType])) {
            foreach ($this->projectors[$eventType] as $projector) {
                $projector($event);
            }
        }
    }
}

// Usage Example
$pdo = new PDO('mysql:host=localhost;dbname=event_sourcing', 'user', 'password');
$eventStore = new PDOEventStore($pdo);
$commandHandler = new CommandHandler($eventStore);
$userReadModel = new UserReadModel($pdo);

// Setup event projectors
$projector = new EventProjector();
$projector->register(UserRegistered::class, [$userReadModel, 'updateFromEvent']);
$projector->register(UserEmailChanged::class, [$userReadModel, 'updateFromEvent']);
$projector->register(UserActivated::class, [$userReadModel, 'updateFromEvent']);
$projector->register(UserDeactivated::class, [$userReadModel, 'updateFromEvent']);

// Register a new user
$registerCommand = new RegisterUserCommand(
    uniqid('user_', true),
    'john@example.com',
    'John Doe'
);
$commandHandler->handle($registerCommand);

// Project the event to read model
$events = $eventStore->getEvents($registerCommand->getUserId());
foreach ($events as $event) {
    $projector->project($event);
}

// Query the read model
$user = $userReadModel->findUserById($registerCommand->getUserId());
echo "User registered: " . $user['name'] . " (" . $user['email'] . ")";
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">4</div>
                            <h3 class="question-title">Microservices Architecture with PHP</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Microservices</span>
                            <span class="question-badge">Architecture</span>
                            <span class="question-badge">Scalability</span>
                        </div>
                        <div class="question-content">
                            <p>Design and implement a microservices architecture using PHP, including service communication, data consistency, and deployment strategies.</p>

                            <div class="highlight-box success">
                                <div class="highlight-header">
                                    <i class="fas fa-network-wired highlight-icon"></i>
                                    <strong>PHP Microservices Challenges:</strong>
                                </div>
                                <ul>
                                    <li><strong>Shared Nothing:</strong> Each service has its own database</li>
                                    <li><strong>API Gateway:</strong> Single entry point for all services</li>
                                    <li><strong>Service Discovery:</strong> Dynamic service location</li>
                                    <li><strong>Circuit Breaker:</strong> Fault tolerance between services</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="PHP Microservices Architecture">
// PHP Microservices Architecture Implementation

interface ServiceInterface
{
    public function getName(): string;
    public function getVersion(): string;
    public function isHealthy(): bool;
}

abstract class BaseMicroservice implements ServiceInterface
{
    protected string $name;
    protected string $version;
    protected Logger $logger;
    protected Database $database;

    public function __construct(string $name, string $version)
    {
        $this->name = $name;
        $this->version = $version;
        $this->logger = new Logger($name);
        $this->database = $this->initializeDatabase();
    }

    abstract protected function initializeDatabase(): Database;

    public function getName(): string
    {
        return $this->name;
    }

    public function getVersion(): string
    {
        return $this->version;
    }

    public function isHealthy(): bool
    {
        try {
            $this->database->ping();
            return true;
        } catch (Exception $e) {
            $this->logger->error('Health check failed', ['error' => $e->getMessage()]);
            return false;
        }
    }
}

// User Service
class UserService extends BaseMicroservice
{
    public function __construct()
    {
        parent::__construct('user-service', '1.0.0');
    }

    protected function initializeDatabase(): Database
    {
        return new Database('users_db');
    }

    public function createUser(array $userData): array
    {
        $this->logger->info('Creating user', ['email' => $userData['email']]);

        // Validate user data
        $this->validateUserData($userData);

        // Check if user already exists
        if ($this->userExists($userData['email'])) {
            throw new UserAlreadyExistsException('User with this email already exists');
        }

        // Hash password
        $userData['password_hash'] = password_hash($userData['password'], PASSWORD_ARGON2ID);

        // Save to database
        $userId = $this->database->insert('users', $userData);

        // Publish user created event
        $this->publishEvent('user.created', [
            'user_id' => $userId,
            'email' => $userData['email'],
            'name' => $userData['name']
        ]);

        $this->logger->info('User created successfully', ['user_id' => $userId]);

        return $this->getUserById($userId);
    }

    public function getUserById(int $userId): ?array
    {
        return $this->database->find('users', $userId);
    }

    public function updateUser(int $userId, array $updates): array
    {
        $this->database->update('users', $userId, $updates);

        $this->publishEvent('user.updated', [
            'user_id' => $userId,
            'updates' => $updates
        ]);

        return $this->getUserById($userId);
    }

    private function validateUserData(array $data): void
    {
        if (empty($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException('Valid email is required');
        }

        if (empty($data['name']) || strlen($data['name']) < 2) {
            throw new InvalidArgumentException('Name must be at least 2 characters');
        }

        if (empty($data['password']) || strlen($data['password']) < 8) {
            throw new InvalidArgumentException('Password must be at least 8 characters');
        }
    }

    private function userExists(string $email): bool
    {
        $user = $this->database->query(
            'SELECT id FROM users WHERE email = ?',
            [$email]
        );
        return !empty($user);
    }

    private function publishEvent(string $eventType, array $data): void
    {
        // Publish to message broker (RabbitMQ, Kafka, etc.)
        MessageBroker::publish($eventType, $data);
    }
}

// Order Service
class OrderService extends BaseMicroservice
{
    private HttpClient $httpClient;

    public function __construct()
    {
        parent::__construct('order-service', '1.0.0');
        $this->httpClient = new HttpClient();
    }

    protected function initializeDatabase(): Database
    {
        return new Database('orders_db');
    }

    public function createOrder(int $userId, array $items): array
    {
        $this->logger->info('Creating order', ['user_id' => $userId, 'items_count' => count($items)]);

        // Verify user exists via User Service
        $user = $this->getUserFromUserService($userId);
        if (!$user) {
            throw new UserNotFoundException('User not found');
        }

        // Calculate total and validate items
        $orderData = $this->calculateOrderTotal($items);

        // Reserve inventory via Inventory Service
        $this->reserveInventory($items);

        // Process payment via Payment Service
        $paymentResult = $this->processPayment($userId, $orderData['total']);

        // Create order record
        $orderData['user_id'] = $userId;
        $orderData['payment_id'] = $paymentResult['payment_id'];
        $orderData['status'] = 'confirmed';

        $orderId = $this->database->insert('orders', $orderData);

        // Publish order created event
        $this->publishEvent('order.created', [
            'order_id' => $orderId,
            'user_id' => $userId,
            'total' => $orderData['total'],
            'items' => $items
        ]);

        $this->logger->info('Order created successfully', ['order_id' => $orderId]);

        return $this->getOrderById($orderId);
    }

    private function getUserFromUserService(int $userId): ?array
    {
        try {
            $response = $this->httpClient->get("http://user-service:8080/users/{$userId}");
            return $response['data'] ?? null;
        } catch (Exception $e) {
            $this->logger->error('Failed to get user from User Service', [
                'user_id' => $userId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    private function calculateOrderTotal(array $items): array
    {
        $total = 0;
        $orderItems = [];

        foreach ($items as $item) {
            // Get product price from Product Service
            $product = $this->getProductFromProductService($item['product_id']);

            if ($product['stock'] < $item['quantity']) {
                throw new InsufficientStockException("Insufficient stock for product {$item['product_id']}");
            }

            $itemTotal = $product['price'] * $item['quantity'];
            $total += $itemTotal;

            $orderItems[] = [
                'product_id' => $item['product_id'],
                'quantity' => $item['quantity'],
                'price' => $product['price'],
                'total' => $itemTotal
            ];
        }

        return [
            'total' => $total,
            'items' => $orderItems
        ];
    }

    private function getProductFromProductService(int $productId): array
    {
        $response = $this->httpClient->get("http://product-service:8080/products/{$productId}");
        return $response['data'];
    }

    private function reserveInventory(array $items): void
    {
        $this->httpClient->post('http://inventory-service:8080/inventory/reserve', [
            'items' => $items
        ]);
    }

    private function processPayment(int $userId, float $amount): array
    {
        return $this->httpClient->post('http://payment-service:8080/payments/charge', [
            'user_id' => $userId,
            'amount' => $amount,
            'currency' => 'USD'
        ]);
    }

    public function getOrderById(int $orderId): ?array
    {
        return $this->database->find('orders', $orderId);
    }

    private function publishEvent(string $eventType, array $data): void
    {
        MessageBroker::publish($eventType, $data);
    }
}

// API Gateway
class ApiGateway
{
    private ServiceRegistry $serviceRegistry;
    private RateLimiter $rateLimiter;
    private AuthService $authService;
    private Logger $logger;

    public function __construct()
    {
        $this->serviceRegistry = new ServiceRegistry();
        $this->rateLimiter = new RateLimiter();
        $this->authService = new AuthService();
        $this->logger = new Logger('api-gateway');
    }

    public function handleRequest(string $method, string $path, array $data = [], array $headers = []): array
    {
        try {
            // Rate limiting
            $clientId = $this->getClientId($headers);
            if (!$this->rateLimiter->allow($clientId)) {
                return $this->errorResponse(429, 'Rate limit exceeded');
            }

            // Authentication & Authorization
            $user = $this->authService->authenticate($headers);
            if (!$user) {
                return $this->errorResponse(401, 'Unauthorized');
            }

            // Route to appropriate service
            $route = $this->parseRoute($path);
            if (!$route) {
                return $this->errorResponse(404, 'Route not found');
            }

            // Check service health
            if (!$this->serviceRegistry->isServiceHealthy($route['service'])) {
                return $this->errorResponse(503, 'Service unavailable');
            }

            // Add user context to request
            $data['user_context'] = $user;

            // Forward request to service
            $response = $this->forwardRequest($route, $method, $data, $headers);

            // Log request
            $this->logger->info('Request processed', [
                'method' => $method,
                'path' => $path,
                'user_id' => $user['id'],
                'response_status' => $response['status'] ?? 200
            ]);

            return $response;

        } catch (Exception $e) {
            $this->logger->error('Request failed', [
                'method' => $method,
                'path' => $path,
                'error' => $e->getMessage()
            ]);

            return $this->errorResponse(500, 'Internal server error');
        }
    }

    private function parseRoute(string $path): ?array
    {
        $routes = [
            '/users' => ['service' => 'user-service', 'path' => '/users'],
            '/orders' => ['service' => 'order-service', 'path' => '/orders'],
            '/products' => ['service' => 'product-service', 'path' => '/products'],
        ];

        foreach ($routes as $prefix => $route) {
            if (strpos($path, $prefix) === 0) {
                $route['internal_path'] = str_replace($prefix, $route['path'], $path);
                return $route;
            }
        }

        return null;
    }

    private function forwardRequest(array $route, string $method, array $data, array $headers): array
    {
        $serviceUrl = $this->serviceRegistry->getServiceUrl($route['service']);
        $url = $serviceUrl . $route['internal_path'];

        // Add correlation ID for tracing
        $correlationId = $headers['X-Correlation-ID'] ?? uniqid('req_', true);
        $headers['X-Correlation-ID'] = $correlationId;

        $httpClient = new HttpClient();
        return $httpClient->request($method, $url, $data, $headers);
    }

    private function getClientId(array $headers): string
    {
        return $headers['X-Forwarded-For'] ?? $headers['REMOTE_ADDR'] ?? 'unknown';
    }

    private function errorResponse(int $status, string $message): array
    {
        return [
            'status' => $status,
            'data' => [
                'error' => $message,
                'timestamp' => date('c')
            ]
        ];
    }
}

// Service Registry with Circuit Breaker
class ServiceRegistry
{
    private array $services = [];
    private array $circuitBreakers = [];

    public function registerService(string $name, string $url, array $metadata = []): void
    {
        $this->services[$name] = [
            'url' => $url,
            'metadata' => $metadata,
            'last_health_check' => time(),
            'healthy' => true
        ];

        $this->circuitBreakers[$name] = new CircuitBreaker($name, 5, 60);
    }

    public function getServiceUrl(string $name): ?string
    {
        if (!isset($this->services[$name])) {
            return null;
        }

        $circuitBreaker = $this->circuitBreakers[$name];
        if ($circuitBreaker->isOpen()) {
            return null; // Service is down
        }

        return $this->services[$name]['url'];
    }

    public function isServiceHealthy(string $name): bool
    {
        if (!isset($this->services[$name])) {
            return false;
        }

        // Perform health check if needed (every 30 seconds)
        if (time() - $this->services[$name]['last_health_check'] > 30) {
            $healthy = $this->performHealthCheck($this->services[$name]['url']);
            $this->services[$name]['healthy'] = $healthy;
            $this->services[$name]['last_health_check'] = time();

            $circuitBreaker = $this->circuitBreakers[$name];
            if ($healthy) {
                $circuitBreaker->recordSuccess();
            } else {
                $circuitBreaker->recordFailure();
            }
        }

        return $this->services[$name]['healthy'] && !$this->circuitBreakers[$name]->isOpen();
    }

    private function performHealthCheck(string $url): bool
    {
        try {
            $httpClient = new HttpClient();
            $response = $httpClient->get($url . '/health');
            return ($response['status'] ?? 500) === 200;
        } catch (Exception $e) {
            return false;
        }
    }
}

// Circuit Breaker Implementation
class CircuitBreaker
{
    private string $serviceName;
    private int $failureThreshold;
    private int $timeout;
    private int $failureCount = 0;
    private int $lastFailureTime = 0;
    private string $state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN

    public function __construct(string $serviceName, int $failureThreshold = 5, int $timeout = 60)
    {
        $this->serviceName = $serviceName;
        $this->failureThreshold = $failureThreshold;
        $this->timeout = $timeout;
    }

    public function isOpen(): bool
    {
        if ($this->state === 'OPEN') {
            if (time() - $this->lastFailureTime > $this->timeout) {
                $this->state = 'HALF_OPEN';
                return false;
            }
            return true;
        }
        return false;
    }

    public function recordSuccess(): void
    {
        $this->failureCount = 0;
        $this->state = 'CLOSED';
    }

    public function recordFailure(): void
    {
        $this->failureCount++;
        $this->lastFailureTime = time();

        if ($this->failureCount >= $this->failureThreshold) {
            $this->state = 'OPEN';
        }
    }
}

// Message Broker for Event-Driven Communication
class MessageBroker
{
    private static array $subscribers = [];

    public static function subscribe(string $eventType, callable $callback): void
    {
        if (!isset(self::$subscribers[$eventType])) {
            self::$subscribers[$eventType] = [];
        }
        self::$subscribers[$eventType][] = $callback;
    }

    public static function publish(string $eventType, array $data): void
    {
        if (!isset(self::$subscribers[$eventType])) {
            return;
        }

        foreach (self::$subscribers[$eventType] as $callback) {
            try {
                $callback($data);
            } catch (Exception $e) {
                error_log("Event handler failed for {$eventType}: " . $e->getMessage());
            }
        }
    }
}

// Usage Example
$apiGateway = new ApiGateway();

// Register services
$serviceRegistry = new ServiceRegistry();
$serviceRegistry->registerService('user-service', 'http://user-service:8080');
$serviceRegistry->registerService('order-service', 'http://order-service:8080');

// Handle API request
$request = [
    'method' => 'POST',
    'path' => '/orders',
    'data' => [
        'user_id' => 123,
        'items' => [
            ['product_id' => 456, 'quantity' => 2],
            ['product_id' => 789, 'quantity' => 1]
        ]
    ],
    'headers' => [
        'Authorization' => 'Bearer token123',
        'X-Correlation-ID' => 'req_abc123'
    ]
];

$response = $apiGateway->handleRequest(
    $request['method'],
    $request['path'],
    $request['data'],
    $request['headers']
);

echo json_encode($response);
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">5</div>
                            <h3 class="question-title">PHP Performance Optimization & Caching</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Performance</span>
                            <span class="question-badge">Caching</span>
                            <span class="question-badge">Optimization</span>
                        </div>
                        <div class="question-content">
                            <p>Implement comprehensive performance optimization strategies for high-traffic PHP applications, including multi-layer caching and database optimization.</p>

                            <div class="highlight-box info">
                                <div class="highlight-header">
                                    <i class="fas fa-tachometer-alt highlight-icon"></i>
                                    <strong>Performance Optimization Layers:</strong>
                                </div>
                                <ul>
                                    <li><strong>HTTP Caching:</strong> Browser, CDN, and reverse proxy caching</li>
                                    <li><strong>Application Caching:</strong> Opcode, object, and query result caching</li>
                                    <li><strong>Database Optimization:</strong> Connection pooling, query optimization, indexing</li>
                                    <li><strong>Infrastructure:</strong> Load balancing, horizontal scaling, async processing</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="PHP Performance Optimization & Multi-Layer Caching">
// PHP Performance Optimization & Multi-Layer Caching

interface CacheInterface
{
    public function get(string $key);
    public function set(string $key, $value, int $ttl = 3600): bool;
    public function delete(string $key): bool;
    public function clear(): bool;
    public function has(string $key): bool;
}

class MultiLevelCache implements CacheInterface
{
    private array $layers = [];
    private Logger $logger;

    public function __construct()
    {
        $this->logger = new Logger('cache');
        $this->initializeCacheLayers();
    }

    private function initializeCacheLayers(): void
    {
        // L1: APCu (Application Cache - fastest)
        if (extension_loaded('apcu')) {
            $this->layers[] = new APCuCache();
        }

        // L2: Redis (Distributed Cache)
        $this->layers[] = new RedisCache([
            'host' => getenv('REDIS_HOST') ?: 'localhost',
            'port' => getenv('REDIS_PORT') ?: 6379,
            'password' => getenv('REDIS_PASSWORD')
        ]);

        // L3: Database (Persistent Cache)
        $this->layers[] = new DatabaseCache();
    }

    public function get(string $key)
    {
        // Check each layer from fastest to slowest
        foreach ($this->layers as $layer) {
            $value = $layer->get($key);
            if ($value !== null) {
                $this->logger->debug("Cache hit for key: {$key}");
                // Warm up faster layers
                $this->warmUpFasterLayers($key, $value);
                return $value;
            }
        }

        $this->logger->debug("Cache miss for key: {$key}");
        return null;
    }

    public function set(string $key, $value, int $ttl = 3600): bool
    {
        $success = true;

        // Set in all layers
        foreach ($this->layers as $layer) {
            if (!$layer->set($key, $value, $ttl)) {
                $success = false;
                $this->logger->warning("Failed to set cache in layer: " . get_class($layer));
            }
        }

        return $success;
    }

    public function delete(string $key): bool
    {
        $success = true;

        foreach ($this->layers as $layer) {
            if (!$layer->delete($key)) {
                $success = false;
            }
        }

        return $success;
    }

    public function clear(): bool
    {
        $success = true;

        foreach ($this->layers as $layer) {
            if (!$layer->clear()) {
                $success = false;
            }
        }

        return $success;
    }

    public function has(string $key): bool
    {
        foreach ($this->layers as $layer) {
            if ($layer->has($key)) {
                return true;
            }
        }
        return false;
    }

    private function warmUpFasterLayers(string $key, $value): void
    {
        // Warm up L1 cache if it missed but L2/L3 had the data
        if (count($this->layers) > 1 && !$this->layers[0]->has($key)) {
            $this->layers[0]->set($key, $value, 3600);
        }
    }
}

class APCuCache implements CacheInterface
{
    public function get(string $key)
    {
        return apcu_fetch($key, $success) ? $success : null;
    }

    public function set(string $key, $value, int $ttl = 3600): bool
    {
        return apcu_store($key, $value, $ttl);
    }

    public function delete(string $key): bool
    {
        return apcu_delete($key);
    }

    public function clear(): bool
    {
        return apcu_clear_cache();
    }

    public function has(string $key): bool
    {
        return apcu_exists($key);
    }
}

class RedisCache implements CacheInterface
{
    private Redis $redis;

    public function __construct(array $config = [])
    {
        $this->redis = new Redis();
        $this->redis->connect(
            $config['host'] ?? 'localhost',
            $config['port'] ?? 6379
        );

        if (isset($config['password'])) {
            $this->redis->auth($config['password']);
        }
    }

    public function get(string $key)
    {
        $value = $this->redis->get($key);
        return $value !== false ? unserialize($value) : null;
    }

    public function set(string $key, $value, int $ttl = 3600): bool
    {
        return $this->redis->setex($key, $ttl, serialize($value));
    }

    public function delete(string $key): bool
    {
        return $this->redis->del($key) > 0;
    }

    public function clear(): bool
    {
        return $this->redis->flushdb();
    }

    public function has(string $key): bool
    {
        return $this->redis->exists($key);
    }
}

class DatabaseCache implements CacheInterface
{
    private PDO $pdo;

    public function __construct()
    {
        $this->pdo = new PDO(
            getenv('DB_DSN') ?: 'mysql:host=localhost;dbname=cache',
            getenv('DB_USER') ?: 'root',
            getenv('DB_PASS') ?: ''
        );
        $this->createTable();
    }

    private function createTable(): void
    {
        $this->pdo->exec("
            CREATE TABLE IF NOT EXISTS cache (
                cache_key VARCHAR(255) PRIMARY KEY,
                cache_value LONGTEXT,
                expires_at TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_expires_at (expires_at)
            )
        ");
    }

    public function get(string $key)
    {
        $stmt = $this->pdo->prepare("
            SELECT cache_value FROM cache
            WHERE cache_key = ? AND expires_at > NOW()
        ");
        $stmt->execute([$key]);
        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($result) {
            return unserialize($result['cache_value']);
        }

        // Clean expired entries
        $this->pdo->exec("DELETE FROM cache WHERE expires_at <= NOW()");

        return null;
    }

    public function set(string $key, $value, int $ttl = 3600): bool
    {
        $expiresAt = date('Y-m-d H:i:s', time() + $ttl);
        $serializedValue = serialize($value);

        $stmt = $this->pdo->prepare("
            INSERT INTO cache (cache_key, cache_value, expires_at)
            VALUES (?, ?, ?)
            ON DUPLICATE KEY UPDATE
            cache_value = VALUES(cache_value),
            expires_at = VALUES(expires_at)
        ");

        return $stmt->execute([$key, $serializedValue, $expiresAt]);
    }

    public function delete(string $key): bool
    {
        $stmt = $this->pdo->prepare("DELETE FROM cache WHERE cache_key = ?");
        return $stmt->execute([$key]);
    }

    public function clear(): bool
    {
        return $this->pdo->exec("TRUNCATE TABLE cache") !== false;
    }

    public function has(string $key): bool
    {
        $stmt = $this->pdo->prepare("
            SELECT 1 FROM cache
            WHERE cache_key = ? AND expires_at > NOW()
        ");
        $stmt->execute([$key]);
        return $stmt->fetch() !== false;
    }
}

// Performance Monitoring
class PerformanceMonitor
{
    private array $metrics = [];
    private Logger $logger;

    public function __construct()
    {
        $this->logger = new Logger('performance');
    }

    public function startTimer(string $operation): void
    {
        $this->metrics[$operation] = [
            'start_time' => microtime(true),
            'start_memory' => memory_get_usage(true)
        ];
    }

    public function endTimer(string $operation): array
    {
        if (!isset($this->metrics[$operation])) {
            return [];
        }

        $start = $this->metrics[$operation];
        $endTime = microtime(true);
        $endMemory = memory_get_usage(true);

        $metrics = [
            'operation' => $operation,
            'duration' => $endTime - $start['start_time'],
            'memory_used' => $endMemory - $start['start_memory'],
            'memory_peak' => memory_get_peak_usage(true),
            'timestamp' => date('c')
        ];

        // Log slow operations
        if ($metrics['duration'] > 1.0) { // More than 1 second
            $this->logger->warning('Slow operation detected', $metrics);
        }

        unset($this->metrics[$operation]);
        return $metrics;
    }

    public function measure(string $operation, callable $callback): mixed
    {
        $this->startTimer($operation);
        try {
            $result = $callback();
            $metrics = $this->endTimer($operation);

            // Log metrics
            $this->logger->info('Operation completed', $metrics);

            return $result;
        } catch (Exception $e) {
            $this->endTimer($operation);
            throw $e;
        }
    }
}

// Database Optimization
class DatabaseOptimizer
{
    private PDO $pdo;
    private MultiLevelCache $cache;

    public function __construct(PDO $pdo, MultiLevelCache $cache)
    {
        $this->pdo = $pdo;
        $this->cache = $cache;
    }

    public function getUserWithPosts(int $userId): ?array
    {
        $cacheKey = "user_posts_{$userId}";

        // Try cache first
        $user = $this->cache->get($cacheKey);
        if ($user) {
            return $user;
        }

        // Cache miss - query database
        $stmt = $this->pdo->prepare("
            SELECT u.*, p.id as post_id, p.title, p.content, p.created_at as post_created_at
            FROM users u
            LEFT JOIN posts p ON u.id = p.user_id AND p.status = 'published'
            WHERE u.id = ?
            ORDER BY p.created_at DESC
        ");
        $stmt->execute([$userId]);
        $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if (empty($rows)) {
            return null;
        }

        // Structure the data
        $user = $rows[0];
        $user['posts'] = [];

        foreach ($rows as $row) {
            if ($row['post_id']) {
                $user['posts'][] = [
                    'id' => $row['post_id'],
                    'title' => $row['title'],
                    'content' => $row['content'],
                    'created_at' => $row['post_created_at']
                ];
            }
        }

        // Remove duplicate columns
        unset($user['post_id'], $user['title'], $user['content'], $user['post_created_at']);

        // Cache for 15 minutes
        $this->cache->set($cacheKey, $user, 900);

        return $user;
    }

    public function getUsersByLocation(string $location, int $limit = 50): array
    {
        $cacheKey = "users_location_{$location}_{$limit}";

        $users = $this->cache->get($cacheKey);
        if ($users) {
            return $users;
        }

        // Use prepared statement with indexed query
        $stmt = $this->pdo->prepare("
            SELECT id, name, email, created_at
            FROM users
            WHERE location = ?
            ORDER BY created_at DESC
            LIMIT ?
        ");
        $stmt->execute([$location, $limit]);
        $users = $stmt->fetchAll(PDO::FETCH_ASSOC);

        // Cache for 10 minutes
        $this->cache->set($cacheKey, $users, 600);

        return $users;
    }

    public function invalidateUserCache(int $userId): void
    {
        // Invalidate all cache keys related to this user
        $this->cache->delete("user_posts_{$userId}");

        // Also invalidate any list caches that might contain this user
        // In a real implementation, you'd use cache tags or a more sophisticated invalidation strategy
    }
}

// HTTP Caching Middleware
class HttpCacheMiddleware
{
    private MultiLevelCache $cache;
    private array $cacheableRoutes = [];

    public function __construct(MultiLevelCache $cache)
    {
        $this->cache = $cache;
        $this->setupCacheableRoutes();
    }

    private function setupCacheableRoutes(): void
    {
        $this->cacheableRoutes = [
            'GET /api/products' => 300,  // 5 minutes
            'GET /api/categories' => 600, // 10 minutes
            'GET /api/user/profile' => 180, // 3 minutes
        ];
    }

    public function handle(string $method, string $path, callable $next): mixed
    {
        $routeKey = "{$method} {$path}";

        // Check if route is cacheable
        if (!isset($this->cacheableRoutes[$routeKey])) {
            return $next();
        }

        $ttl = $this->cacheableRoutes[$routeKey];
        $cacheKey = $this->generateCacheKey($method, $path);

        // Try to get from cache
        $cachedResponse = $this->cache->get($cacheKey);
        if ($cachedResponse) {
            header('X-Cache: HIT');
            return $cachedResponse;
        }

        // Cache miss - execute request
        $response = $next();
        header('X-Cache: MISS');

        // Cache the response
        if ($this->isSuccessfulResponse($response)) {
            $this->cache->set($cacheKey, $response, $ttl);
        }

        return $response;
    }

    private function generateCacheKey(string $method, string $path): string
    {
        $userId = $_SESSION['user_id'] ?? 'anonymous';
        return "http_cache_{$userId}_{$method}_{$path}";
    }

    private function isSuccessfulResponse($response): bool
    {
        // Check if response is successful (not an error)
        return !isset($response['error']);
    }
}

// Query Optimization
class QueryOptimizer
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    public function analyzeQuery(string $sql, array $params = []): array
    {
        // Enable profiling
        $this->pdo->exec("SET profiling = 1");

        // Execute query
        $stmt = $this->pdo->prepare($sql);
        $startTime = microtime(true);
        $stmt->execute($params);
        $endTime = microtime(true);

        // Get profiling data
        $profileResult = $this->pdo->query("SHOW PROFILE")->fetchAll(PDO::FETCH_ASSOC);

        // Get EXPLAIN plan
        $explainStmt = $this->pdo->prepare("EXPLAIN " . $sql);
        $explainStmt->execute($params);
        $explainPlan = $explainStmt->fetchAll(PDO::FETCH_ASSOC);

        // Disable profiling
        $this->pdo->exec("SET profiling = 0");

        return [
            'execution_time' => $endTime - $startTime,
            'profile' => $profileResult,
            'explain_plan' => $explainPlan,
            'row_count' => $stmt->rowCount()
        ];
    }

    public function getSlowQueries(): array
    {
        // Get slow queries from MySQL slow query log
        $stmt = $this->pdo->query("
            SELECT sql_text, exec_count, avg_timer_wait/1000000000 as avg_time_sec,
                   rows_examined, rows_sent
            FROM performance_schema.events_statements_summary_by_digest
            WHERE avg_timer_wait > 1000000000  -- More than 1 second
            ORDER BY avg_timer_wait DESC
            LIMIT 20
        ");

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function suggestIndexes(): array
    {
        // Get queries that could benefit from indexes
        $stmt = $this->pdo->query("
            SELECT digest_text, schema_name, avg_timer_wait
            FROM performance_schema.events_statements_summary_by_digest
            WHERE schema_name IS NOT NULL
            AND digest_text LIKE '%WHERE%'
            AND digest_text NOT LIKE '%ORDER BY%'
            ORDER BY avg_timer_wait DESC
            LIMIT 10
        ");

        $suggestions = [];
        foreach ($stmt->fetchAll(PDO::FETCH_ASSOC) as $row) {
            $suggestions[] = [
                'query' => $row['digest_text'],
                'avg_time' => $row['avg_timer_wait'] / 1000000000,
                'suggested_index' => $this->analyzeIndexSuggestion($row['digest_text'])
            ];
        }

        return $suggestions;
    }

    private function analyzeIndexSuggestion(string $query): string
    {
        // Simple analysis - look for WHERE conditions
        if (preg_match('/WHERE\s+(\w+)\s*=\s*\?/', $query, $matches)) {
            return "CREATE INDEX idx_{$matches[1]} ON table_name ({$matches[1]});";
        }

        return "Consider adding appropriate indexes based on WHERE conditions";
    }
}

// Usage Example
$cache = new MultiLevelCache();
$performanceMonitor = new PerformanceMonitor();

// Database optimization
$dbOptimizer = new DatabaseOptimizer($pdo, $cache);

// HTTP caching middleware
$httpCache = new HttpCacheMiddleware($cache);

// Query optimization
$queryOptimizer = new QueryOptimizer($pdo);

// Example usage with performance monitoring
$userData = $performanceMonitor->measure('get_user_with_posts', function() use ($dbOptimizer) {
    return $dbOptimizer->getUserWithPosts(123);
});

// Analyze a slow query
$queryAnalysis = $queryOptimizer->analyzeQuery("
    SELECT u.name, COUNT(o.id) as order_count
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.created_at > ?
    GROUP BY u.id
    HAVING order_count > 5
", ['2023-01-01']);

echo "Query executed in: " . $queryAnalysis['execution_time'] . " seconds\n";

// Get slow queries
$slowQueries = $queryOptimizer->getSlowQueries();

// Get index suggestions
$indexSuggestions = $queryOptimizer->suggestIndexes();
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">6</div>
                            <h3 class="question-title">PHP Security Architecture & Threat Mitigation</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Security</span>
                            <span class="question-badge">Architecture</span>
                            <span class="question-badge">OWASP</span>
                        </div>
                        <div class="question-content">
                            <p>Design comprehensive security architecture for PHP applications, implementing defense in depth with multiple security layers and threat mitigation strategies.</p>

                            <div class="highlight-box danger">
                                <div class="highlight-header">
                                    <i class="fas fa-shield-alt highlight-icon"></i>
                                    <strong>Security Layers:</strong>
                                </div>
                                <ul>
                                    <li><strong>Network Security:</strong> WAF, DDoS protection, SSL/TLS</li>
                                    <li><strong>Application Security:</strong> Input validation, authentication, authorization</li>
                                    <li><strong>Data Security:</strong> Encryption at rest and in transit</li>
                                    <li><strong>Infrastructure Security:</strong> Container security, secrets management</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Code Example
                        </button>

                        <div class="code-block" data-lang="php" data-title="PHP Security Architecture Implementation">
// PHP Security Architecture & Threat Mitigation

interface SecurityValidatorInterface
{
    public function validate($input, array $rules = []): ValidationResult;
    public function sanitize($input, string $type = 'string');
}

interface AuthenticationInterface
{
    public function authenticate(array $credentials): ?User;
    public function isAuthenticated(): bool;
    public function getCurrentUser(): ?User;
    public function logout(): void;
}

interface AuthorizationInterface
{
    public function hasPermission(User $user, string $permission): bool;
    public function hasRole(User $user, string $role): bool;
    public function canAccess(User $user, string $resource, string $action): bool;
}

class ValidationResult
{
    private bool $valid;
    private array $errors = [];
    private array $sanitizedData = [];

    public function __construct(bool $valid, array $errors = [], array $sanitizedData = [])
    {
        $this->valid = $valid;
        $this->errors = $errors;
        $this->sanitizedData = $sanitizedData;
    }

    public function isValid(): bool
    {
        return $this->valid;
    }

    public function getErrors(): array
    {
        return $this->errors;
    }

    public function getSanitizedData(): array
    {
        return $this->sanitizedData;
    }
}

// Advanced Input Validation & Sanitization
class SecurityValidator implements SecurityValidatorInterface
{
    private array $validationRules = [
        'email' => '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/',
        'phone' => '/^\+?[\d\s\-\(\)]{10,}$/',
        'url' => '/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/',
        'ip' => '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/',
        'credit_card' => '/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\d{3})\d{11})$/',
    ];

    public function validate($input, array $rules = []): ValidationResult
    {
        $errors = [];
        $sanitized = [];

        if (is_array($input)) {
            foreach ($input as $key => $value) {
                $fieldRules = $rules[$key] ?? [];
                $result = $this->validateField($key, $value, $fieldRules);

                if (!$result['valid']) {
                    $errors[$key] = $result['errors'];
                } else {
                    $sanitized[$key] = $result['sanitized'];
                }
            }
        } else {
            $result = $this->validateField('input', $input, $rules);
            if (!$result['valid']) {
                $errors['input'] = $result['errors'];
            } else {
                $sanitized['input'] = $result['sanitized'];
            }
        }

        return new ValidationResult(empty($errors), $errors, $sanitized);
    }

    private function validateField(string $fieldName, $value, array $rules): array
    {
        $errors = [];
        $sanitized = $value;

        foreach ($rules as $rule => $parameter) {
            switch ($rule) {
                case 'required':
                    if ($parameter && (is_null($value) || $value === '')) {
                        $errors[] = "{$fieldName} is required";
                    }
                    break;

                case 'email':
                    if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {
                        $errors[] = "{$fieldName} must be a valid email address";
                    }
                    break;

                case 'min_length':
                    if (strlen($value) < $parameter) {
                        $errors[] = "{$fieldName} must be at least {$parameter} characters";
                    }
                    break;

                case 'max_length':
                    if (strlen($value) > $parameter) {
                        $errors[] = "{$fieldName} must not exceed {$parameter} characters";
                    }
                    break;

                case 'pattern':
                    if (!preg_match($parameter, $value)) {
                        $errors[] = "{$fieldName} format is invalid";
                    }
                    break;

                case 'in':
                    if (!in_array($value, $parameter)) {
                        $errors[] = "{$fieldName} must be one of: " . implode(', ', $parameter);
                    }
                    break;

                case 'numeric':
                    if (!is_numeric($value)) {
                        $errors[] = "{$fieldName} must be numeric";
                    }
                    break;

                case 'range':
                    if ($value < $parameter[0] || $value > $parameter[1]) {
                        $errors[] = "{$fieldName} must be between {$parameter[0]} and {$parameter[1]}";
                    }
                    break;

                case 'no_sql_injection':
                    if ($this->containsSqlInjection($value)) {
                        $errors[] = "{$fieldName} contains potentially dangerous SQL";
                    }
                    break;

                case 'no_xss':
                    if ($this->containsXss($value)) {
                        $errors[] = "{$fieldName} contains potentially dangerous HTML/JavaScript";
                    }
                    break;
            }
        }

        // Sanitize the value
        $sanitized = $this->sanitize($sanitized);

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'sanitized' => $sanitized
        ];
    }

    public function sanitize($input, string $type = 'string')
    {
        if (is_array($input)) {
            return array_map([$this, 'sanitize'], $input);
        }

        switch ($type) {
            case 'email':
                return filter_var($input, FILTER_SANITIZE_EMAIL);
            case 'url':
                return filter_var($input, FILTER_SANITIZE_URL);
            case 'int':
                return filter_var($input, FILTER_SANITIZE_NUMBER_INT);
            case 'float':
                return filter_var($input, FILTER_SANITIZE_NUMBER_FLOAT, FILTER_FLAG_ALLOW_FRACTION);
            case 'html':
                return htmlspecialchars($input, ENT_QUOTES, 'UTF-8');
            default:
                // General string sanitization
                return htmlspecialchars(strip_tags(trim($input)), ENT_QUOTES, 'UTF-8');
        }
    }

    private function containsSqlInjection(string $value): bool
    {
        $sqlPatterns = [
            '/(\b(union|select|insert|update|delete|drop|create|alter)\b)/i',
            '/(-{2}|\/\*|\*\/)/',  // Comments
            '/(;|\|)/',  // Semicolon or pipe
            '/(\b(or|and)\b\s+\d+\s*=\s*\d+)/i',  // Tautologies
        ];

        foreach ($sqlPatterns as $pattern) {
            if (preg_match($pattern, $value)) {
                return true;
            }
        }

        return false;
    }

    private function containsXss(string $value): bool
    {
        $xssPatterns = [
            '/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi',
            '/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi',
            '/javascript:/i',
            '/on\w+\s*=/i',
            '/<[^>]*>/',  // Basic HTML tags
        ];

        foreach ($xssPatterns as $pattern) {
            if (preg_match($pattern, $value)) {
                return true;
            }
        }

        return false;
    }
}

// JWT Authentication with Advanced Security
class JWTAuthenticator implements AuthenticationInterface
{
    private string $secretKey;
    private int $tokenExpiry;
    private array $activeTokens = [];

    public function __construct(string $secretKey, int $tokenExpiry = 3600)
    {
        $this->secretKey = $secretKey;
        $this->tokenExpiry = $tokenExpiry;
    }

    public function authenticate(array $credentials): ?User
    {
        $validator = new SecurityValidator();

        $validation = $validator->validate($credentials, [
            'email' => ['required' => true, 'email' => true, 'no_xss' => true],
            'password' => ['required' => true, 'min_length' => 8]
        ]);

        if (!$validation->isValid()) {
            throw new AuthenticationException('Invalid credentials format');
        }

        $data = $validation->getSanitizedData();

        // Verify credentials against database
        $user = $this->verifyCredentials($data['email'], $data['password']);

        if ($user) {
            // Generate JWT token
            $token = $this->generateToken($user);

            // Store token for revocation capability
            $this->activeTokens[$token] = [
                'user_id' => $user->getId(),
                'expires_at' => time() + $this->tokenExpiry,
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown'
            ];

            // Set session for additional security layer
            $this->setSecureSession($user, $token);

            return $user;
        }

        // Log failed authentication attempt
        $this->logFailedAttempt($data['email'], $_SERVER['REMOTE_ADDR'] ?? 'unknown');

        return null;
    }

    public function isAuthenticated(): bool
    {
        $token = $this->getTokenFromRequest();

        if (!$token) {
            return false;
        }

        return $this->validateToken($token) !== null;
    }

    public function getCurrentUser(): ?User
    {
        $token = $this->getTokenFromRequest();

        if (!$token) {
            return null;
        }

        $payload = $this->validateToken($token);

        if (!$payload) {
            return null;
        }

        // Check if token is in active tokens (for revocation)
        if (!isset($this->activeTokens[$token])) {
            return null;
        }

        // Check token expiry
        if ($this->activeTokens[$token]['expires_at'] < time()) {
            unset($this->activeTokens[$token]);
            return null;
        }

        // Additional security checks
        if (!$this->validateTokenSecurity($token)) {
            return null;
        }

        return $this->getUserById($payload['user_id']);
    }

    public function logout(): void
    {
        $token = $this->getTokenFromRequest();

        if ($token && isset($this->activeTokens[$token])) {
            unset($this->activeTokens[$token]);
        }

        // Clear session
        session_destroy();

        // Clear any remember-me cookies
        if (isset($_COOKIE['remember_token'])) {
            setcookie('remember_token', '', time() - 3600, '/', '', true, true);
        }
    }

    private function generateToken(User $user): string
    {
        $header = json_encode([
            'alg' => 'HS256',
            'typ' => 'JWT'
        ]);

        $payload = json_encode([
            'user_id' => $user->getId(),
            'email' => $user->getEmail(),
            'role' => $user->getRole(),
            'iat' => time(),
            'exp' => time() + $this->tokenExpiry,
            'iss' => 'secure-api',
            'aud' => 'client-app',
            'jti' => bin2hex(random_bytes(16)) // Unique token ID
        ]);

        $headerEncoded = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($header));
        $payloadEncoded = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($payload));

        $signature = hash_hmac('sha256', $headerEncoded . "." . $payloadEncoded, $this->secretKey, true);
        $signatureEncoded = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($signature));

        return $headerEncoded . '.' . $payloadEncoded . '.' . $signatureEncoded;
    }

    private function validateToken(string $token): ?array
    {
        $parts = explode('.', $token);

        if (count($parts) !== 3) {
            return null;
        }

        $header = $parts[0];
        $payload = $parts[1];
        $signature = $parts[2];

        // Verify signature
        $expectedSignature = hash_hmac('sha256', $header . "." . $payload, $this->secretKey, true);
        $expectedSignatureEncoded = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($expectedSignature));

        if (!hash_equals($signature, $expectedSignatureEncoded)) {
            return null;
        }

        // Decode payload
        $payloadDecoded = json_decode(base64_decode(str_replace(['-', '_'], ['+', '/'], $payload)), true);

        if (!$payloadDecoded) {
            return null;
        }

        // Check expiry
        if (isset($payloadDecoded['exp']) && $payloadDecoded['exp'] < time()) {
            return null;
        }

        return $payloadDecoded;
    }

    private function validateTokenSecurity(string $token): bool
    {
        if (!isset($this->activeTokens[$token])) {
            return false;
        }

        $tokenData = $this->activeTokens[$token];

        // Check IP address (for additional security)
        $currentIp = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        if ($tokenData['ip_address'] !== $currentIp) {
            // Log suspicious activity
            error_log("Token used from different IP: {$currentIp} vs {$tokenData['ip_address']}");
            // In production, you might want to invalidate the token or require additional verification
        }

        // Check user agent (basic protection against token theft)
        $currentUa = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';
        if ($tokenData['user_agent'] !== $currentUa) {
            error_log("Token used with different user agent");
        }

        return true;
    }

    private function getTokenFromRequest(): ?string
    {
        // Check Authorization header first
        $headers = getallheaders();
        if (isset($headers['Authorization'])) {
            $authHeader = $headers['Authorization'];
            if (preg_match('/Bearer\s+(.*)$/i', $authHeader, $matches)) {
                return $matches[1];
            }
        }

        // Check session
        if (isset($_SESSION['jwt_token'])) {
            return $_SESSION['jwt_token'];
        }

        // Check cookie (less secure, but sometimes necessary)
        if (isset($_COOKIE['auth_token'])) {
            return $_COOKIE['auth_token'];
        }

        return null;
    }

    private function setSecureSession(User $user, string $token): void
    {
        session_regenerate_id(true); // Prevent session fixation

        $_SESSION['user_id'] = $user->getId();
        $_SESSION['user_email'] = $user->getEmail();
        $_SESSION['user_role'] = $user->getRole();
        $_SESSION['jwt_token'] = $token;
        $_SESSION['login_time'] = time();
        $_SESSION['ip_address'] = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        $_SESSION['user_agent'] = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';

        // Set session cookie parameters for security
        session_set_cookie_params([
            'lifetime' => 0, // Session cookie
            'path' => '/',
            'domain' => '', // Current domain only
            'secure' => isset($_SERVER['HTTPS']), // HTTPS only in production
            'httponly' => true, // Prevent JavaScript access
            'samesite' => 'Strict' // CSRF protection
        ]);
    }

    private function verifyCredentials(string $email, string $password): ?User
    {
        // In real implementation, check against database with proper password verification
        // This is a simplified example
        $stmt = $this->db->prepare("SELECT * FROM users WHERE email = ? AND status = 'active'");
        $stmt->execute([$email]);
        $userData = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($userData && password_verify($password, $userData['password_hash'])) {
            return new User($userData);
        }

        return null;
    }

    private function logFailedAttempt(string $email, string $ip): void
    {
        error_log("Failed login attempt for email: {$email} from IP: {$ip}");

        // In production, you might want to:
        // - Increment failed attempt counter
        // - Implement progressive delays
        // - Send alerts for multiple failures
        // - Implement account lockout after N attempts
    }
}

// Role-Based Access Control (RBAC)
class RBACAuthorizer implements AuthorizationInterface
{
    private array $roles = [];
    private array $permissions = [];
    private array $rolePermissions = [];

    public function __construct()
    {
        $this->initializeRolesAndPermissions();
    }

    private function initializeRolesAndPermissions(): void
    {
        // Define permissions
        $this->permissions = [
            'user.create' => 'Create new users',
            'user.read' => 'View user information',
            'user.update' => 'Modify user information',
            'user.delete' => 'Delete users',
            'admin.panel' => 'Access admin panel',
            'reports.view' => 'View reports',
            'settings.manage' => 'Manage system settings'
        ];

        // Define roles and their permissions
        $this->roles = [
            'user' => 'Regular user with basic access',
            'moderator' => 'User moderator with elevated permissions',
            'admin' => 'System administrator with full access',
            'super_admin' => 'Super administrator with all permissions'
        ];

        // Assign permissions to roles
        $this->rolePermissions = [
            'user' => ['user.read'],
            'moderator' => ['user.read', 'user.update', 'reports.view'],
            'admin' => ['user.create', 'user.read', 'user.update', 'user.delete', 'reports.view', 'settings.manage'],
            'super_admin' => array_keys($this->permissions) // All permissions
        ];
    }

    public function hasPermission(User $user, string $permission): bool
    {
        $userRole = $user->getRole();

        if (!isset($this->rolePermissions[$userRole])) {
            return false;
        }

        return in_array($permission, $this->rolePermissions[$userRole]);
    }

    public function hasRole(User $user, string $role): bool
    {
        return $user->getRole() === $role;
    }

    public function canAccess(User $user, string $resource, string $action): bool
    {
        $permission = $resource . '.' . $action;
        return $this->hasPermission($user, $permission);
    }

    public function addRole(string $roleName, string $description): void
    {
        $this->roles[$roleName] = $description;
        $this->rolePermissions[$roleName] = [];
    }

    public function assignPermissionToRole(string $role, string $permission): void
    {
        if (!isset($this->rolePermissions[$role])) {
            throw new InvalidArgumentException("Role '{$role}' does not exist");
        }

        if (!isset($this->permissions[$permission])) {
            throw new InvalidArgumentException("Permission '{$permission}' does not exist");
        }

        if (!in_array($permission, $this->rolePermissions[$role])) {
            $this->rolePermissions[$role][] = $permission;
        }
    }

    public function removePermissionFromRole(string $role, string $permission): void
    {
        if (isset($this->rolePermissions[$role])) {
            $this->rolePermissions[$role] = array_filter(
                $this->rolePermissions[$role],
                fn($p) => $p !== $permission
            );
        }
    }

    public function getUserPermissions(User $user): array
    {
        $role = $user->getRole();
        return $this->rolePermissions[$role] ?? [];
    }

    public function getAllPermissions(): array
    {
        return $this->permissions;
    }

    public function getAllRoles(): array
    {
        return $this->roles;
    }
}

// Security Middleware
class SecurityMiddleware
{
    private SecurityValidator $validator;
    private JWTAuthenticator $authenticator;
    private RBACAuthorizer $authorizer;
    private array $rateLimits = [];

    public function __construct()
    {
        $this->validator = new SecurityValidator();
        $this->authenticator = new JWTAuthenticator(getenv('JWT_SECRET'));
        $this->authorizer = new RBACAuthorizer();
    }

    public function handleRequest(array $request, callable $next): mixed
    {
        try {
            // Rate limiting
            $this->checkRateLimit($request);

            // Input validation and sanitization
            $request = $this->validateAndSanitizeInput($request);

            // Authentication
            $user = $this->authenticateRequest($request);
            $request['user'] = $user;

            // Authorization
            $this->authorizeRequest($user, $request);

            // Security headers
            $this->setSecurityHeaders();

            // CSRF protection for state-changing operations
            $this->validateCsrfToken($request);

            // Log security event
            $this->logSecurityEvent('request_processed', $request, $user);

            // Process the request
            $response = $next($request);

            return $response;

        } catch (SecurityException $e) {
            $this->logSecurityEvent('security_violation', $request, null, $e->getMessage());
            return $this->createErrorResponse(403, 'Security violation: ' . $e->getMessage());

        } catch (AuthenticationException $e) {
            $this->logSecurityEvent('authentication_failed', $request);
            return $this->createErrorResponse(401, 'Authentication failed');

        } catch (AuthorizationException $e) {
            $this->logSecurityEvent('authorization_failed', $request, $request['user'] ?? null);
            return $this->createErrorResponse(403, 'Access denied');

        } catch (ValidationException $e) {
            return $this->createErrorResponse(400, 'Validation error: ' . $e->getMessage());

        } catch (Exception $e) {
            $this->logSecurityEvent('unexpected_error', $request, null, $e->getMessage());
            return $this->createErrorResponse(500, 'Internal server error');
        }
    }

    private function checkRateLimit(array $request): void
    {
        $clientId = $this->getClientIdentifier($request);
        $endpoint = $request['endpoint'] ?? 'unknown';

        $key = $clientId . ':' . $endpoint;
        $currentTime = time();

        // Simple rate limiting (in production, use Redis or similar)
        if (!isset($this->rateLimits[$key])) {
            $this->rateLimits[$key] = ['count' => 0, 'reset_time' => $currentTime + 60];
        }

        $limit = $this->rateLimits[$key];

        // Reset counter if time window passed
        if ($currentTime > $limit['reset_time']) {
            $limit['count'] = 0;
            $limit['reset_time'] = $currentTime + 60;
        }

        // Check limit (100 requests per minute)
        if ($limit['count'] >= 100) {
            throw new SecurityException('Rate limit exceeded');
        }

        $limit['count']++;
        $this->rateLimits[$key] = $limit;
    }

    private function validateAndSanitizeInput(array $request): array
    {
        $rules = $this->getValidationRules($request['endpoint'] ?? '');

        $validation = $this->validator->validate($request['data'] ?? [], $rules);

        if (!$validation->isValid()) {
            throw new ValidationException('Input validation failed: ' . implode(', ', $validation->getErrors()));
        }

        $request['data'] = $validation->getSanitizedData();
        return $request;
    }

    private function getValidationRules(string $endpoint): array
    {
        $rulesets = [
            '/api/users' => [
                'name' => ['required' => true, 'max_length' => 100, 'no_xss' => true],
                'email' => ['required' => true, 'email' => true],
                'password' => ['required' => true, 'min_length' => 8]
            ],
            '/api/posts' => [
                'title' => ['required' => true, 'max_length' => 200, 'no_xss' => true],
                'content' => ['required' => true, 'max_length' => 10000, 'no_xss' => true]
            ]
        ];

        return $rulesets[$endpoint] ?? [];
    }

    private function authenticateRequest(array $request): ?User
    {
        // Skip authentication for public endpoints
        $publicEndpoints = ['/api/auth/login', '/api/auth/register', '/health'];
        if (in_array($request['endpoint'] ?? '', $publicEndpoints)) {
            return null;
        }

        return $this->authenticator->getCurrentUser();
    }

    private function authorizeRequest(?User $user, array $request): void
    {
        $endpoint = $request['endpoint'] ?? '';
        $method = $request['method'] ?? 'GET';

        // Define required permissions for endpoints
        $permissions = [
            'POST /api/users' => 'user.create',
            'PUT /api/users' => 'user.update',
            'DELETE /api/users' => 'user.delete',
            'GET /api/admin' => 'admin.panel'
        ];

        $requiredPermission = $permissions[$method . ' ' . $endpoint] ?? null;

        if ($requiredPermission && (!$user || !$this->authorizer->hasPermission($user, $requiredPermission))) {
            throw new AuthorizationException('Insufficient permissions');
        }
    }

    private function validateCsrfToken(array $request): void
    {
        // CSRF protection for state-changing operations
        $stateChangingMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];

        if (in_array($request['method'] ?? '', $stateChangingMethods)) {
            $token = $request['headers']['X-CSRF-Token'] ?? '';

            if (!$this->isValidCsrfToken($token)) {
                throw new SecurityException('Invalid CSRF token');
            }
        }
    }

    private function isValidCsrfToken(string $token): bool
    {
        // In production, compare against session-stored token
        return !empty($token) && strlen($token) > 10; // Simplified check
    }

    private function setSecurityHeaders(): void
    {
        header('X-Content-Type-Options: nosniff');
        header('X-Frame-Options: DENY');
        header('X-XSS-Protection: 1; mode=block');
        header('Strict-Transport-Security: max-age=31536000; includeSubDomains');
        header('Content-Security-Policy: default-src \'self\'; script-src \'self\' \'unsafe-inline\'; style-src \'self\' \'unsafe-inline\'');
        header('Referrer-Policy: strict-origin-when-cross-origin');
        header('Permissions-Policy: geolocation=(), microphone=(), camera=()');
    }

    private function getClientIdentifier(array $request): string
    {
        // Use IP address or API key for rate limiting
        return $request['ip'] ?? $_SERVER['REMOTE_ADDR'] ?? 'unknown';
    }

    private function logSecurityEvent(string $event, array $request, ?User $user = null, string $details = ''): void
    {
        $logData = [
            'event' => $event,
            'timestamp' => date('c'),
            'ip' => $request['ip'] ?? 'unknown',
            'endpoint' => $request['endpoint'] ?? 'unknown',
            'method' => $request['method'] ?? 'unknown',
            'user_id' => $user ? $user->getId() : null,
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
            'details' => $details
        ];

        error_log('SECURITY: ' . json_encode($logData));
    }

    private function createErrorResponse(int $status, string $message): array
    {
        http_response_code($status);
        return [
            'status' => 'error',
            'message' => $message,
            'timestamp' => date('c')
        ];
    }
}

// Usage Example
$securityMiddleware = new SecurityMiddleware();

// Example request handling
$request = [
    'method' => 'POST',
    'endpoint' => '/api/users',
    'data' => [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'password' => 'securePassword123'
    ],
    'headers' => [
        'Authorization' => 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...',
        'X-CSRF-Token' => 'csrf_token_here'
    ],
    'ip' => '192.168.1.100'
];

$response = $securityMiddleware->handleRequest($request, function($request) {
    // Your application logic here
    return [
        'status' => 'success',
        'data' => ['user_id' => 123, 'message' => 'User created successfully']
    ];
});

echo json_encode($response);
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">7</div>
                            <h3 class="question-title">Legacy Code Refactoring Strategies</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Refactoring</span>
                            <span class="question-badge">Legacy Code</span>
                            <span class="question-badge">Architecture</span>
                        </div>
                        <div class="question-content">
                            <p>Design and implement a comprehensive strategy for refactoring large-scale legacy PHP applications while maintaining business continuity.</p>

                            <div class="highlight-box warning">
                                <div class="highlight-header">
                                    <i class="fas fa-code-branch highlight-icon"></i>
                                    <strong>Legacy Code Challenges:</strong>
                                </div>
                                <ul>
                                    <li><strong>Unknown Dependencies:</strong> Spaghetti code with unclear relationships</li>
                                    <li><strong>Missing Tests:</strong> No safety net for refactoring</li>
                                    <li><strong>Business Critical:</strong> Can't break existing functionality</li>
                                    <li><strong>Team Resistance:</strong> Developers fear touching legacy code</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Legacy Code Refactoring Strategy
                        </button>

                        <div class="code-block" data-lang="php" data-title="Legacy Code Refactoring Strategy">
// Legacy Code Refactoring Strategy
// Systematic approach to modernizing legacy PHP applications

interface RefactoringStrategy
{
    public function canRefactor(string $code): bool;
    public function getRefactoringSteps(): array;
    public function estimateEffort(string $code): int;
    public function applyRefactoring(string $code): string;
}

abstract class BaseRefactoringStrategy implements RefactoringStrategy
{
    protected CodeAnalyzer $analyzer;
    protected TestGenerator $testGenerator;

    public function __construct()
    {
        $this->analyzer = new CodeAnalyzer();
        $this->testGenerator = new TestGenerator();
    }

    abstract public function canRefactor(string $code): bool;
    abstract public function getRefactoringSteps(): array;
    abstract public function applyRefactoring(string $code): string;

    public function estimateEffort(string $code): int
    {
        $complexity = $this->analyzer->calculateComplexity($code);
        $dependencies = $this->analyzer->findDependencies($code);
        $testCoverage = $this->analyzer->getTestCoverage($code);

        // Effort estimation based on complexity and dependencies
        $effort = $complexity * 2; // Base effort
        $effort += count($dependencies) * 3; // Dependency overhead
        $effort += (100 - $testCoverage) * 0.5; // Testing effort

        return (int) $effort;
    }
}

class ProceduralToOOPRefactoring extends BaseRefactoringStrategy
{
    public function canRefactor(string $code): bool
    {
        // Check if code contains global functions and variables
        return strpos($code, 'function ') !== false &&
               strpos($code, 'global ') !== false;
    }

    public function getRefactoringSteps(): array
    {
        return [
            '1. Identify cohesive functions and data',
            '2. Create class structure with proper encapsulation',
            '3. Extract methods from global functions',
            '4. Replace global variables with class properties',
            '5. Implement dependency injection',
            '6. Add comprehensive tests',
            '7. Gradually migrate usage'
        ];
    }

    public function applyRefactoring(string $code): string
    {
        // Automated refactoring steps
        $code = $this->extractClassFromFunctions($code);
        $code = $this->convertGlobalVariablesToProperties($code);
        $code = $this->addConstructorAndDependencies($code);

        return $code;
    }

    private function extractClassFromFunctions(string $code): string
    {
        // Extract functions into a class
        preg_match_all('/function\s+(\w+)\s*\((.*?)\)\s*{([^}]+)}/s', $code, $matches);

        $className = $this->generateClassName($code);
        $methods = '';

        foreach ($matches[1] as $i => $functionName) {
            $params = $matches[2][$i];
            $body = $matches[3][$i];

            $methods .= "    public function {$functionName}({$params}) {\n";
            $methods .= "        {$body}\n";
            $methods .= "    }\n\n";
        }

        return "<?php\n\nclass {$className}\n{\n{$methods}}\n";
    }

    private function convertGlobalVariablesToProperties(string $code): string
    {
        // Convert global variables to private properties
        $properties = '';
        $modifiedCode = $code;

        // Find global variable declarations
        if (preg_match_all('/global\s+\$(\w+)/', $code, $matches)) {
            foreach ($matches[1] as $varName) {
                $properties .= "    private \${$varName};\n";
                // Replace global usage with $this
                $modifiedCode = str_replace("global \${$varName}", "", $modifiedCode);
                $modifiedCode = preg_replace("/(?<!\$this->)\${$varName}/", "\$this->{$varName}", $modifiedCode);
            }
        }

        // Inject properties into class
        $modifiedCode = preg_replace('/class\s+(\w+)\s*{/', "class \$1\n{\n{$properties}", $modifiedCode);

        return $modifiedCode;
    }

    private function addConstructorAndDependencies(string $code): string
    {
        // Add constructor for dependency injection
        $constructor = "\n    public function __construct(Database \$db, Logger \$logger)\n";
        $constructor .= "    {\n";
        $constructor .= "        \$this->db = \$db;\n";
        $constructor .= "        \$this->logger = \$logger;\n";
        $constructor .= "    }\n";

        // Inject after class opening
        $code = preg_replace('/class\s+(\w+)\s*{\s*\n/', "class \$1\n{\n{$constructor}", $code);

        return $code;
    }

    private function generateClassName(string $code): string
    {
        // Generate meaningful class name from code content
        $functionNames = [];
        preg_match_all('/function\s+(\w+)/', $code, $matches);

        if (!empty($matches[1])) {
            $mainFunction = $matches[1][0];
            return ucfirst($mainFunction) . 'Service';
        }

        return 'RefactoredService';
    }
}

class SpaghettiCodeUntangler extends BaseRefactoringStrategy
{
    public function canRefactor(string $code): bool
    {
        // Check for spaghetti code indicators
        $nestedIfCount = substr_count($code, 'if') - substr_count($code, 'elseif');
        $globalVarCount = substr_count($code, 'global');

        return $nestedIfCount > 5 || $globalVarCount > 3;
    }

    public function getRefactoringSteps(): array
    {
        return [
            '1. Identify business logic clusters',
            '2. Extract conditional logic into strategy classes',
            '3. Break down large functions into smaller methods',
            '4. Implement factory pattern for object creation',
            '5. Add interface abstractions',
            '6. Create comprehensive test suite',
            '7. Refactor incrementally with feature flags'
        ];
    }

    public function applyRefactoring(string $code): string
    {
        $code = $this->extractConditionalLogic($code);
        $code = $this->breakDownLargeFunctions($code);
        $code = $this->addInterfaceAbstractions($code);

        return $code;
    }

    private function extractConditionalLogic(string $code): string
    {
        // Extract complex if-else chains into strategy pattern
        $patterns = [
            '/if\s*\(\s*\$(\w+)\s*===\s*[\'"]([^\'"]+)[\'"]\s*\)/' =>
                'extractConditionToStrategy',
        ];

        foreach ($patterns as $pattern => $method) {
            $code = $this->$method($code, $pattern);
        }

        return $code;
    }

    private function extractConditionToStrategy(string $code, string $pattern): string
    {
        // This is a simplified example - real implementation would be more complex
        return $code . "\n\n// TODO: Extract conditional logic to strategy pattern";
    }

    private function breakDownLargeFunctions(string $code): string
    {
        // Identify functions longer than 50 lines and break them down
        preg_match_all('/function\s+(\w+)\s*\([^}]{200,}/s', $code, $matches);

        foreach ($matches[1] as $functionName) {
            $code .= "\n\n// TODO: Break down function {$functionName} into smaller methods";
        }

        return $code;
    }

    private function addInterfaceAbstractions(string $code): string
    {
        // Add interface definitions for better abstraction
        $interfaces = "\ninterface BusinessLogicInterface {\n    public function execute(array \$data): array;\n}\n";

        return $interfaces . $code;
    }
}

class RefactoringOrchestrator
{
    private array $strategies;
    private CodeAnalyzer $analyzer;
    private TestSuite $testSuite;
    private BackupManager $backupManager;

    public function __construct()
    {
        $this->strategies = [
            new ProceduralToOOPRefactoring(),
            new SpaghettiCodeUntangler(),
        ];
        $this->analyzer = new CodeAnalyzer();
        $this->testSuite = new TestSuite();
        $this->backupManager = new BackupManager();
    }

    public function refactorFile(string $filePath): RefactoringResult
    {
        $originalCode = file_get_contents($filePath);
        $this->backupManager->createBackup($filePath, $originalCode);

        // Analyze code and determine refactoring strategy
        $analysis = $this->analyzer->analyze($filePath);

        $applicableStrategies = [];
        foreach ($this->strategies as $strategy) {
            if ($strategy->canRefactor($originalCode)) {
                $applicableStrategies[] = $strategy;
            }
        }

        if (empty($applicableStrategies)) {
            return new RefactoringResult(false, 'No applicable refactoring strategies found');
        }

        // Apply refactoring incrementally
        $refactoredCode = $originalCode;
        $appliedStrategies = [];

        foreach ($applicableStrategies as $strategy) {
            try {
                $refactoredCode = $strategy->applyRefactoring($refactoredCode);
                $appliedStrategies[] = get_class($strategy);

                // Verify refactoring didn't break functionality
                if (!$this->verifyRefactoring($originalCode, $refactoredCode)) {
                    throw new RefactoringException('Refactoring verification failed');
                }

            } catch (Exception $e) {
                // Rollback this strategy
                $this->backupManager->rollback($filePath);
                return new RefactoringResult(false, 'Refactoring failed: ' . $e->getMessage());
            }
        }

        // Generate tests for refactored code
        $this->generateTests($refactoredCode, $filePath);

        // Save refactored code
        file_put_contents($filePath, $refactoredCode);

        return new RefactoringResult(true, 'Refactoring completed successfully', [
            'applied_strategies' => $appliedStrategies,
            'generated_tests' => true,
            'backup_created' => true
        ]);
    }

    private function verifyRefactoring(string $original, string $refactored): bool
    {
        // Basic verification - check syntax
        if (!@eval("return true; {$refactored}")) {
            return false;
        }

        // Run existing tests
        return $this->testSuite->runTests();
    }

    private function generateTests(string $code, string $filePath): void
    {
        $testFile = $this->testGenerator->generateTestFile($code, $filePath);
        file_put_contents($this->getTestFilePath($filePath), $testFile);
    }

    private function getTestFilePath(string $filePath): string
    {
        $pathInfo = pathinfo($filePath);
        return $pathInfo['dirname'] . '/tests/' . $pathInfo['filename'] . 'Test.php';
    }
}

class RefactoringResult
{
    public bool $success;
    public string $message;
    public array $metadata;

    public function __construct(bool $success, string $message, array $metadata = [])
    {
        $this->success = $success;
        $this->message = $message;
        $this->metadata = $metadata;
    }
}

class CodeAnalyzer
{
    public function analyze(string $filePath): array
    {
        $code = file_get_contents($filePath);

        return [
            'complexity' => $this->calculateComplexity($code),
            'dependencies' => $this->findDependencies($code),
            'test_coverage' => $this->getTestCoverage($code),
            'code_smells' => $this->detectCodeSmells($code)
        ];
    }

    public function calculateComplexity(string $code): int
    {
        // Cyclomatic complexity calculation
        $complexity = 1; // Base complexity

        // Count decision points
        $patterns = ['/if\s*\(/', '/else\s*{/', '/for\s*\(/', '/while\s*\(/', '/case\s+/'];
        foreach ($patterns as $pattern) {
            $complexity += preg_match_all($pattern, $code);
        }

        return $complexity;
    }

    public function findDependencies(string $code): array
    {
        $dependencies = [];

        // Find class instantiations
        if (preg_match_all('/new\s+(\w+)/', $code, $matches)) {
            $dependencies = array_merge($dependencies, $matches[1]);
        }

        // Find function calls that might be dependencies
        if (preg_match_all('/(\w+)\s*\(/', $code, $matches)) {
            $dependencies = array_merge($dependencies, $matches[1]);
        }

        return array_unique($dependencies);
    }

    public function getTestCoverage(string $code): int
    {
        // This would integrate with a test coverage tool
        // Simplified implementation
        return rand(0, 100); // Mock coverage
    }

    public function detectCodeSmells(string $code): array
    {
        $smells = [];

        // Long methods (>50 lines)
        if (preg_match('/function\s+\w+.*{[^}]{1000,}}/s', $code)) {
            $smells[] = 'Long method detected';
        }

        // Global variables
        if (strpos($code, 'global ') !== false) {
            $smells[] = 'Global variables detected';
        }

        // Deep nesting
        if (preg_match('/if.*if.*if.*if/s', $code)) {
            $smells[] = 'Deep nesting detected';
        }

        return $smells;
    }
}

class TestGenerator
{
    public function generateTestFile(string $code, string $originalFile): string
    {
        $className = $this->extractClassName($code);
        $testClassName = $className . 'Test';

        $testMethods = $this->generateTestMethods($code);

        return "<?php\n\ndeclare(strict_types=1);\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass {$testClassName} extends TestCase\n{\n{$testMethods}\n}\n";
    }

    private function extractClassName(string $code): string
    {
        if (preg_match('/class\s+(\w+)/', $code, $matches)) {
            return $matches[1];
        }

        return 'RefactoredClass';
    }

    private function generateTestMethods(string $code): string
    {
        $methods = '';

        // Generate basic test methods
        if (preg_match_all('/public\s+function\s+(\w+)/', $code, $matches)) {
            foreach ($matches[1] as $methodName) {
                $methods .= "\n    public function test{$methodName}(): void\n";
                $methods .= "    {\n";
                $methods .= "        // TODO: Implement test for {$methodName}\n";
                $methods .= "        \$this->markTestIncomplete('Test not implemented');\n";
                $methods .= "    }\n";
            }
        }

        return $methods;
    }
}

class BackupManager
{
    private string $backupDir;

    public function __construct(string $backupDir = '/tmp/refactoring_backups')
    {
        $this->backupDir = $backupDir;
        $this->ensureBackupDirExists();
    }

    public function createBackup(string $filePath, string $content): string
    {
        $backupPath = $this->getBackupPath($filePath);
        file_put_contents($backupPath, $content);

        return $backupPath;
    }

    public function rollback(string $filePath): bool
    {
        $backupPath = $this->getBackupPath($filePath);

        if (file_exists($backupPath)) {
            copy($backupPath, $filePath);
            return true;
        }

        return false;
    }

    private function getBackupPath(string $filePath): string
    {
        $fileName = basename($filePath);
        $timestamp = date('Y-m-d_H-i-s');

        return "{$this->backupDir}/{$fileName}.{$timestamp}.backup";
    }

    private function ensureBackupDirExists(): void
    {
        if (!is_dir($this->backupDir)) {
            mkdir($this->backupDir, 0755, true);
        }
    }
}

// Usage Example
$orchestrator = new RefactoringOrchestrator();

// Refactor a legacy file
$result = $orchestrator->refactorFile('/path/to/legacy/code.php');

if ($result->success) {
    echo "Refactoring completed successfully!\n";
    echo "Applied strategies: " . implode(', ', $result->metadata['applied_strategies']) . "\n";
} else {
    echo "Refactoring failed: " . $result->message . "\n";
}
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">8</div>
                            <h3 class="question-title">Testing Strategies for Enterprise PHP Applications</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Testing</span>
                            <span class="question-badge">Quality Assurance</span>
                            <span class="question-badge">Architecture</span>
                        </div>
                        <div class="question-content">
                            <p>Design comprehensive testing strategies for large-scale PHP applications, including unit, integration, and end-to-end testing with proper CI/CD integration.</p>

                            <div class="highlight-box success">
                                <div class="highlight-header">
                                    <i class="fas fa-vial highlight-icon"></i>
                                    <strong>Testing Pyramid Strategy:</strong>
                                </div>
                                <ul>
                                    <li><strong>Unit Tests (70%):</strong> Fast, isolated, high coverage</li>
                                    <li><strong>Integration Tests (20%):</strong> Component interaction, API testing</li>
                                    <li><strong>E2E Tests (10%):</strong> Full user workflows, critical paths</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Testing Framework Implementation
                        </button>

                        <div class="code-block" data-lang="php" data-title="Comprehensive Testing Framework">
// Comprehensive Testing Framework for Enterprise PHP

abstract class TestCase extends PHPUnit\Framework\TestCase
{
    protected Container $container;
    protected Database $testDatabase;

    protected function setUp(): void
    {
        parent::setUp();

        // Initialize test container
        $this->container = $this->createTestContainer();

        // Setup test database
        $this->testDatabase = $this->setupTestDatabase();

        // Begin transaction for test isolation
        $this->testDatabase->beginTransaction();
    }

    protected function tearDown(): void
    {
        // Rollback test changes
        if ($this->testDatabase) {
            $this->testDatabase->rollback();
        }

        parent::tearDown();
    }

    private function createTestContainer(): Container
    {
        $container = new Container();

        // Register test-specific services
        $container->singleton('db', function() {
            return $this->testDatabase;
        });

        $container->singleton('cache', function() {
            return new ArrayCache(); // In-memory cache for tests
        });

        // Mock external services
        $container->singleton('payment.gateway', function() {
            return new MockPaymentGateway();
        });

        return $container;
    }

    private function setupTestDatabase(): Database
    {
        // Create in-memory SQLite database for tests
        $pdo = new PDO('sqlite::memory:');
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

        // Run migrations
        $this->runMigrations($pdo);

        // Seed test data
        $this->seedTestData($pdo);

        return new Database($pdo);
    }

    private function runMigrations(PDO $pdo): void
    {
        $migrations = [
            "CREATE TABLE users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email VARCHAR(255) UNIQUE NOT NULL,
                name VARCHAR(255) NOT NULL,
                password_hash VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )",
            "CREATE TABLE orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                total DECIMAL(10,2) NOT NULL,
                status VARCHAR(50) DEFAULT 'pending',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id)
            )"
        ];

        foreach ($migrations as $migration) {
            $pdo->exec($migration);
        }
    }

    private function seedTestData(PDO $pdo): void
    {
        // Insert test users
        $testUsers = [
            ['email' => 'john@example.com', 'name' => 'John Doe', 'password_hash' => password_hash('password', PASSWORD_DEFAULT)],
            ['email' => 'jane@example.com', 'name' => 'Jane Smith', 'password_hash' => password_hash('password', PASSWORD_DEFAULT)]
        ];

        $stmt = $pdo->prepare("INSERT INTO users (email, name, password_hash) VALUES (?, ?, ?)");
        foreach ($testUsers as $user) {
            $stmt->execute([$user['email'], $user['name'], $user['password_hash']]);
        }
    }

    protected function createTestUser(array $overrides = []): array
    {
        $userData = array_merge([
            'email' => 'test' . uniqid() . '@example.com',
            'name' => 'Test User',
            'password_hash' => password_hash('password', PASSWORD_DEFAULT)
        ], $overrides);

        $this->testDatabase->insert('users', $userData);

        return $this->testDatabase->find('users', $this->testDatabase->lastInsertId());
    }
}

class UserServiceTest extends TestCase
{
    private UserService $userService;

    protected function setUp(): void
    {
        parent::setUp();
        $this->userService = $this->container->get('user.service');
    }

    public function testCreateUserSuccessfully(): void
    {
        $userData = [
            'email' => 'newuser@example.com',
            'name' => 'New User',
            'password' => 'securePassword123'
        ];

        $user = $this->userService->createUser($userData);

        $this->assertNotNull($user);
        $this->assertEquals('newuser@example.com', $user['email']);
        $this->assertEquals('New User', $user['name']);
        $this->assertArrayHasKey('id', $user);
    }

    public function testCreateUserFailsWithDuplicateEmail(): void
    {
        $this->expectException(UserAlreadyExistsException::class);

        $userData = [
            'email' => 'john@example.com', // Already exists from seed data
            'name' => 'Duplicate User',
            'password' => 'password123'
        ];

        $this->userService->createUser($userData);
    }

    public function testGetUserById(): void
    {
        $testUser = $this->createTestUser();

        $user = $this->userService->getUserById($testUser['id']);

        $this->assertNotNull($user);
        $this->assertEquals($testUser['id'], $user['id']);
        $this->assertEquals($testUser['email'], $user['email']);
    }

    public function testUpdateUserProfile(): void
    {
        $testUser = $this->createTestUser();

        $updates = ['name' => 'Updated Name'];
        $updatedUser = $this->userService->updateUser($testUser['id'], $updates);

        $this->assertEquals('Updated Name', $updatedUser['name']);
        $this->assertEquals($testUser['email'], $updatedUser['email']);
    }

    /**
     * @dataProvider invalidEmailProvider
     */
    public function testCreateUserFailsWithInvalidEmail(string $invalidEmail): void
    {
        $this->expectException(InvalidArgumentException::class);

        $userData = [
            'email' => $invalidEmail,
            'name' => 'Test User',
            'password' => 'password123'
        ];

        $this->userService->createUser($userData);
    }

    public function invalidEmailProvider(): array
    {
        return [
            ['notanemail'],
            ['@example.com'],
            ['user@'],
            ['user.example.com'],
            ['']
        ];
    }
}

class OrderServiceIntegrationTest extends TestCase
{
    private OrderService $orderService;
    private UserService $userService;

    protected function setUp(): void
    {
        parent::setUp();
        $this->orderService = $this->container->get('order.service');
        $this->userService = $this->container->get('user.service');
    }

    public function testCreateOrderWithPaymentProcessing(): void
    {
        // Create a test user
        $user = $this->userService->createUser([
            'email' => 'orderuser@example.com',
            'name' => 'Order User',
            'password' => 'password123'
        ]);

        // Create an order
        $orderData = [
            'user_id' => $user['id'],
            'items' => [
                ['product_id' => 1, 'quantity' => 2],
                ['product_id' => 2, 'quantity' => 1]
            ]
        ];

        $order = $this->orderService->createOrder($user['id'], $orderData['items']);

        $this->assertNotNull($order);
        $this->assertEquals($user['id'], $order['user_id']);
        $this->assertEquals('confirmed', $order['status']);
        $this->assertArrayHasKey('total', $order);
        $this->assertGreaterThan(0, $order['total']);
    }

    public function testOrderCreationFailsWhenInventoryUnavailable(): void
    {
        $this->expectException(InsufficientStockException::class);

        $user = $this->createTestUser();

        // Try to order more items than available in inventory
        $orderData = [
            'user_id' => $user['id'],
            'items' => [
                ['product_id' => 1, 'quantity' => 1000] // More than available
            ]
        ];

        $this->orderService->createOrder($user['id'], $orderData['items']);
    }
}

class ApiEndToEndTest extends TestCase
{
    private HttpClient $httpClient;
    private string $baseUrl = 'http://localhost:8000/api';

    protected function setUp(): void
    {
        parent::setUp();
        $this->httpClient = new HttpClient();
    }

    public function testCompleteUserRegistrationAndOrderFlow(): void
    {
        // Register user
        $userData = [
            'email' => 'e2e' . uniqid() . '@example.com',
            'name' => 'E2E Test User',
            'password' => 'password123'
        ];

        $registerResponse = $this->httpClient->post($this->baseUrl . '/register', $userData);
        $this->assertEquals(201, $registerResponse['status']);
        $this->assertArrayHasKey('user_id', $registerResponse['data']);

        $userId = $registerResponse['data']['user_id'];

        // Login
        $loginResponse = $this->httpClient->post($this->baseUrl . '/login', [
            'email' => $userData['email'],
            'password' => $userData['password']
        ]);

        $this->assertEquals(200, $loginResponse['status']);
        $this->assertArrayHasKey('token', $loginResponse['data']);

        $token = $loginResponse['data']['token'];

        // Create order
        $orderData = [
            'items' => [
                ['product_id' => 1, 'quantity' => 2],
                ['product_id' => 2, 'quantity' => 1]
            ]
        ];

        $orderResponse = $this->httpClient->post(
            $this->baseUrl . '/orders',
            $orderData,
            ['Authorization' => 'Bearer ' . $token]
        );

        $this->assertEquals(201, $orderResponse['status']);
        $this->assertArrayHasKey('order_id', $orderResponse['data']);

        // Verify order was created
        $orderId = $orderResponse['data']['order_id'];
        $getOrderResponse = $this->httpClient->get(
            $this->baseUrl . '/orders/' . $orderId,
            [],
            ['Authorization' => 'Bearer ' . $token]
        );

        $this->assertEquals(200, $getOrderResponse['status']);
        $this->assertEquals($userId, $getOrderResponse['data']['user_id']);
        $this->assertEquals('confirmed', $getOrderResponse['data']['status']);
    }
}

class PerformanceTest extends TestCase
{
    private UserService $userService;

    protected function setUp(): void
    {
        parent::setUp();
        $this->userService = $this->container->get('user.service');
    }

    public function testUserCreationPerformance(): void
    {
        $startTime = microtime(true);

        // Create 100 users
        for ($i = 0; $i < 100; $i++) {
            $this->userService->createUser([
                'email' => "perf{$i}@example.com",
                'name' => "Performance User {$i}",
                'password' => 'password123'
            ]);
        }

        $endTime = microtime(true);
        $duration = $endTime - $startTime;

        // Should complete within 5 seconds
        $this->assertLessThan(5.0, $duration, 'User creation should be performant');

        // Average time per user should be less than 50ms
        $avgTimePerUser = ($duration / 100) * 1000;
        $this->assertLessThan(50, $avgTimePerUser, 'Average user creation time should be under 50ms');
    }

    public function testConcurrentUserAccess(): void
    {
        // Test concurrent access to user service
        $user = $this->createTestUser();

        $results = [];

        // Simulate concurrent requests
        for ($i = 0; $i < 10; $i++) {
            $results[] = $this->userService->getUserById($user['id']);
        }

        // All results should be identical
        foreach ($results as $result) {
            $this->assertEquals($user['id'], $result['id']);
            $this->assertEquals($user['email'], $result['email']);
        }
    }
}

class SecurityTest extends TestCase
{
    private UserService $userService;

    protected function setUp(): void
    {
        parent::setUp();
        $this->userService = $this->container->get('user.service');
    }

    public function testPasswordHashingSecurity(): void
    {
        $password = 'mySecurePassword123';

        $user = $this->userService->createUser([
            'email' => 'security@example.com',
            'name' => 'Security Test',
            'password' => $password
        ]);

        // Password should be hashed, not stored in plain text
        $this->assertNotEquals($password, $user['password_hash']);

        // Hash should be different even for same password (due to salt)
        $user2 = $this->userService->createUser([
            'email' => 'security2@example.com',
            'name' => 'Security Test 2',
            'password' => $password
        ]);

        $this->assertNotEquals($user['password_hash'], $user2['password_hash']);
    }

    public function testInputValidationPreventsXSS(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $maliciousInput = [
            'email' => 'test@example.com',
            'name' => '<script>alert("XSS")</script>',
            'password' => 'password123'
        ];

        $this->userService->createUser($maliciousInput);
    }

    public function testSQLInjectionPrevention(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $sqlInjectionAttempt = [
            'email' => 'test@example.com',
            'name' => 'Test User',
            'password' => 'password123\'; DROP TABLE users; --'
        ];

        $this->userService->createUser($sqlInjectionAttempt);
    }
}

// Test Runner with CI/CD Integration
class TestRunner
{
    private array $testSuites;
    private TestReporter $reporter;
    private CoverageAnalyzer $coverageAnalyzer;

    public function __construct()
    {
        $this->testSuites = [
            'unit' => UserServiceTest::class,
            'integration' => OrderServiceIntegrationTest::class,
            'e2e' => ApiEndToEndTest::class,
            'performance' => PerformanceTest::class,
            'security' => SecurityTest::class
        ];

        $this->reporter = new TestReporter();
        $this->coverageAnalyzer = new CoverageAnalyzer();
    }

    public function runAllTests(): TestReport
    {
        $startTime = microtime(true);
        $results = [];

        foreach ($this->testSuites as $suiteName => $testClass) {
            $results[$suiteName] = $this->runTestSuite($testClass);
        }

        $endTime = microtime(true);
        $duration = $endTime - $startTime;

        $report = new TestReport($results, $duration);
        $report->coverage = $this->coverageAnalyzer->analyze();

        $this->reporter->generateReport($report);

        return $report;
    }

    private function runTestSuite(string $testClass): array
    {
        $suite = new PHPUnit\Framework\TestSuite();
        $suite->addTestSuite($testClass);

        $runner = new PHPUnit\TextUI\TestRunner();
        $result = $runner->run($suite, ['verbose' => false]);

        return [
            'passed' => $result->passedCount(),
            'failed' => $result->failureCount(),
            'errors' => $result->errorCount(),
            'skipped' => $result->skippedCount(),
            'time' => $result->time()
        ];
    }
}

class TestReport
{
    public array $results;
    public float $totalTime;
    public float $coverage;

    public function __construct(array $results, float $totalTime)
    {
        $this->results = $results;
        $this->totalTime = $totalTime;
        $this->coverage = 0.0;
    }

    public function getTotalTests(): int
    {
        return array_sum(array_column($this->results, 'passed')) +
               array_sum(array_column($this->results, 'failed')) +
               array_sum(array_column($this->results, 'errors'));
    }

    public function getPassRate(): float
    {
        $total = $this->getTotalTests();
        if ($total === 0) return 0.0;

        $passed = array_sum(array_column($this->results, 'passed'));
        return ($passed / $total) * 100;
    }

    public function hasPassed(): bool
    {
        foreach ($this->results as $result) {
            if ($result['failed'] > 0 || $result['errors'] > 0) {
                return false;
            }
        }
        return true;
    }
}

// CI/CD Integration
class CIQualityGate
{
    private TestRunner $testRunner;
    private CodeAnalyzer $codeAnalyzer;
    private SecurityScanner $securityScanner;

    public function __construct()
    {
        $this->testRunner = new TestRunner();
        $this->codeAnalyzer = new CodeAnalyzer();
        $this->securityScanner = new SecurityScanner();
    }

    public function checkQualityGates(string $branch, array $changedFiles): bool
    {
        $results = [];

        // Run tests
        $testReport = $this->testRunner->runAllTests();
        $results['tests_passed'] = $testReport->hasPassed();
        $results['test_coverage'] = $testReport->coverage;

        // Code quality checks
        $codeQuality = $this->codeAnalyzer->analyzeFiles($changedFiles);
        $results['code_quality_passed'] = $codeQuality['score'] >= 80;

        // Security scanning
        $securityReport = $this->securityScanner->scanFiles($changedFiles);
        $results['security_passed'] = empty($securityReport['vulnerabilities']);

        // Branch-specific rules
        if ($branch === 'main' || $branch === 'master') {
            // Stricter rules for main branch
            $results['main_branch_checks'] = $testReport->coverage >= 90 &&
                                           $codeQuality['complexity'] <= 5;
        }

        // Determine overall success
        $passed = !in_array(false, $results, true);

        if (!$passed) {
            $this->notifyFailure($results);
        }

        return $passed;
    }

    private function notifyFailure(array $results): void
    {
        $failures = array_filter($results, fn($result) => $result === false);

        error_log('Quality gate failed: ' . json_encode(array_keys($failures)));

        // In CI/CD, this would send notifications, block deployment, etc.
    }
}

// Usage in CI/CD pipeline
$qualityGate = new CIQualityGate();
$branch = getenv('GIT_BRANCH') ?: 'develop';
$changedFiles = ['src/UserService.php', 'src/OrderService.php'];

if (!$qualityGate->checkQualityGates($branch, $changedFiles)) {
    exit(1); // Fail the build
}

echo "All quality gates passed!\n";
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">9</div>
                            <h3 class="question-title">API Design and Versioning for PHP Services</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">API Design</span>
                            <span class="question-badge">Versioning</span>
                            <span class="question-badge">REST</span>
                        </div>
                        <div class="question-content">
                            <p>Design scalable, versioned APIs for PHP applications with proper resource modeling, hypermedia controls, and backward compatibility strategies.</p>

                            <div class="highlight-box info">
                                <div class="highlight-header">
                                    <i class="fas fa-plug highlight-icon"></i>
                                    <strong>API Design Principles:</strong>
                                </div>
                                <ul>
                                    <li><strong>Resource-Oriented:</strong> Nouns over verbs, clear resource hierarchy</li>
                                    <li><strong>Stateless:</strong> Each request contains all needed information</li>
                                    <li><strong>Versioned:</strong> Multiple versions running simultaneously</li>
                                    <li><strong>Hypermedia-Driven:</strong> API discoverability through links</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View API Design Implementation
                        </button>

                        <div class="code-block" data-lang="php" data-title="API Design and Versioning Framework">
// API Design and Versioning Framework

interface ApiVersionInterface
{
    public function getVersion(): string;
    public function supportsContentType(string $contentType): bool;
    public function getSupportedContentTypes(): array;
}

interface ResourceInterface
{
    public function getId(): string;
    public function getType(): string;
    public function toArray(): array;
    public function getLinks(): array;
}

interface ApiResponseInterface
{
    public function getStatusCode(): int;
    public function getHeaders(): array;
    public function getBody(): mixed;
    public function getContentType(): string;
}

abstract class AbstractResource implements ResourceInterface
{
    protected string $id;
    protected array $attributes = [];
    protected array $relationships = [];
    protected array $links = [];

    public function __construct(string $id)
    {
        $this->id = $id;
        $this->initializeLinks();
    }

    abstract protected function initializeLinks(): void;

    public function getId(): string
    {
        return $this->id;
    }

    public function getType(): string
    {
        return strtolower((new ReflectionClass($this))->getShortName());
    }

    public function toArray(): array
    {
        return [
            'id' => $this->id,
            'type' => $this->getType(),
            'attributes' => $this->attributes,
            'relationships' => $this->relationships,
            'links' => $this->links
        ];
    }

    public function getLinks(): array
    {
        return $this->links;
    }

    protected function addLink(string $name, string $href): void
    {
        $this->links[$name] = ['href' => $href];
    }

    protected function setAttribute(string $key, $value): void
    {
        $this->attributes[$key] = $value;
    }

    protected function addRelationship(string $name, ResourceInterface $resource): void
    {
        $this->relationships[$name] = [
            'data' => [
                'id' => $resource->getId(),
                'type' => $resource->getType()
            ]
        ];
    }
}

class UserResource extends AbstractResource
{
    private User $user;

    public function __construct(User $user)
    {
        parent::__construct((string) $user->getId());
        $this->user = $user;

        $this->setAttribute('email', $user->getEmail());
        $this->setAttribute('name', $user->getName());
        $this->setAttribute('created_at', $user->getCreatedAt()->format('c'));
        $this->setAttribute('is_active', $user->isActive());
    }

    protected function initializeLinks(): void
    {
        $this->addLink('self', "/api/v1/users/{$this->id}");
        $this->addLink('orders', "/api/v1/users/{$this->id}/orders");
        $this->addLink('profile', "/api/v1/users/{$this->id}/profile");
    }
}

class ApiResponse implements ApiResponseInterface
{
    private int $statusCode;
    private array $headers;
    private mixed $body;
    private string $contentType;

    public function __construct(mixed $body, int $statusCode = 200, string $contentType = 'application/json')
    {
        $this->body = $body;
        $this->statusCode = $statusCode;
        $this->contentType = $contentType;
        $this->headers = [];

        $this->setHeader('Content-Type', $contentType);
    }

    public function getStatusCode(): int
    {
        return $this->statusCode;
    }

    public function getHeaders(): array
    {
        return $this->headers;
    }

    public function getBody(): mixed
    {
        return $this->body;
    }

    public function getContentType(): string
    {
        return $this->contentType;
    }

    public function setHeader(string $name, string $value): void
    {
        $this->headers[$name] = $value;
    }

    public function toJson(): string
    {
        if (is_array($this->body) || is_object($this->body)) {
            return json_encode($this->body, JSON_PRETTY_PRINT);
        }

        return (string) $this->body;
    }
}

class JsonApiResponse extends ApiResponse
{
    public function __construct($data, int $statusCode = 200)
    {
        parent::__construct($data, $statusCode, 'application/vnd.api+json');

        // Add JSON:API specific headers
        $this->setHeader('X-Content-Type-Options', 'nosniff');
    }

    public function toJson(): string
    {
        $response = [
            'jsonapi' => ['version' => '1.0'],
            'data' => $this->body
        ];

        return json_encode($response, JSON_PRETTY_PRINT);
    }
}

class ApiController
{
    protected ApiVersionInterface $apiVersion;
    protected ContentNegotiator $contentNegotiator;

    public function __construct(ApiVersionInterface $apiVersion)
    {
        $this->apiVersion = $apiVersion;
        $this->contentNegotiator = new ContentNegotiator();
    }

    protected function respond(ResourceInterface $resource, int $statusCode = 200): ApiResponseInterface
    {
        $acceptedType = $this->contentNegotiator->getAcceptedContentType();

        if ($acceptedType === 'application/vnd.api+json') {
            return new JsonApiResponse($resource->toArray(), $statusCode);
        }

        return new ApiResponse($resource->toArray(), $statusCode);
    }

    protected function respondCollection(array $resources, int $statusCode = 200): ApiResponseInterface
    {
        $data = array_map(fn($resource) => $resource->toArray(), $resources);

        $acceptedType = $this->contentNegotiator->getAcceptedContentType();

        if ($acceptedType === 'application/vnd.api+json') {
            return new JsonApiResponse($data, $statusCode);
        }

        return new ApiResponse($data, $statusCode);
    }

    protected function error(string $message, int $statusCode = 400, array $details = []): ApiResponseInterface
    {
        $error = [
            'error' => [
                'message' => $message,
                'status_code' => $statusCode,
                'details' => $details
            ]
        ];

        return new ApiResponse($error, $statusCode);
    }
}

class UserController extends ApiController
{
    private UserService $userService;

    public function __construct(ApiVersionInterface $apiVersion, UserService $userService)
    {
        parent::__construct($apiVersion);
        $this->userService = $userService;
    }

    public function index(Request $request): ApiResponseInterface
    {
        try {
            $page = $request->get('page', 1);
            $limit = $request->get('limit', 20);

            $users = $this->userService->getUsers($page, $limit);
            $userResources = array_map(fn($user) => new UserResource($user), $users);

            return $this->respondCollection($userResources);
        } catch (Exception $e) {
            return $this->error('Failed to retrieve users', 500);
        }
    }

    public function show(Request $request, string $id): ApiResponseInterface
    {
        try {
            $user = $this->userService->getUserById($id);

            if (!$user) {
                return $this->error('User not found', 404);
            }

            $userResource = new UserResource($user);
            return $this->respond($userResource);
        } catch (Exception $e) {
            return $this->error('Failed to retrieve user', 500);
        }
    }

    public function store(Request $request): ApiResponseInterface
    {
        try {
            $data = $request->getBody();
            $this->validateUserData($data);

            $user = $this->userService->createUser($data);
            $userResource = new UserResource($user);

            return $this->respond($userResource, 201);
        } catch (ValidationException $e) {
            return $this->error('Validation failed', 422, $e->getErrors());
        } catch (Exception $e) {
            return $this->error('Failed to create user', 500);
        }
    }

    public function update(Request $request, string $id): ApiResponseInterface
    {
        try {
            $data = $request->getBody();
            $this->validateUserData($data, false); // Partial validation for updates

            $user = $this->userService->updateUser($id, $data);
            $userResource = new UserResource($user);

            return $this->respond($userResource);
        } catch (NotFoundException $e) {
            return $this->error('User not found', 404);
        } catch (ValidationException $e) {
            return $this->error('Validation failed', 422, $e->getErrors());
        } catch (Exception $e) {
            return $this->error('Failed to update user', 500);
        }
    }

    public function destroy(Request $request, string $id): ApiResponseInterface
    {
        try {
            $this->userService->deleteUser($id);
            return new ApiResponse(null, 204);
        } catch (NotFoundException $e) {
            return $this->error('User not found', 404);
        } catch (Exception $e) {
            return $this->error('Failed to delete user', 500);
        }
    }

    private function validateUserData(array $data, bool $requireAll = true): void
    {
        $rules = [
            'email' => ['required' => $requireAll, 'email' => true],
            'name' => ['required' => $requireAll, 'max_length' => 100],
            'password' => ['required' => $requireAll, 'min_length' => 8]
        ];

        $validator = new SecurityValidator();
        $result = $validator->validate($data, $rules);

        if (!$result->isValid()) {
            throw new ValidationException('Invalid user data', $result->getErrors());
        }
    }
}

abstract class ApiVersion implements ApiVersionInterface
{
    protected string $version;
    protected array $supportedContentTypes;

    public function __construct()
    {
        $this->supportedContentTypes = [
            'application/json',
            'application/vnd.api+json'
        ];
    }

    public function getVersion(): string
    {
        return $this->version;
    }

    public function supportsContentType(string $contentType): bool
    {
        return in_array($contentType, $this->supportedContentTypes);
    }

    public function getSupportedContentTypes(): array
    {
        return $this->supportedContentTypes;
    }
}

class ApiV1 extends ApiVersion
{
    protected string $version = '1.0.0';

    public function __construct()
    {
        parent::__construct();
        // V1 specific configurations
    }
}

class ApiV2 extends ApiVersion
{
    protected string $version = '2.0.0';

    public function __construct()
    {
        parent::__construct();
        // V2 might support additional content types
        $this->supportedContentTypes[] = 'application/xml';
    }
}

class ApiRouter
{
    private array $routes = [];
    private ApiVersionInterface $defaultVersion;

    public function __construct(ApiVersionInterface $defaultVersion)
    {
        $this->defaultVersion = $defaultVersion;
    }

    public function addRoute(string $method, string $path, string $controller, string $action): void
    {
        $this->routes[$method][$path] = [
            'controller' => $controller,
            'action' => $action
        ];
    }

    public function dispatch(Request $request): ApiResponseInterface
    {
        try {
            $version = $this->determineVersion($request);
            $method = $request->getMethod();
            $path = $request->getPath();

            // Check if route exists
            if (!isset($this->routes[$method][$path])) {
                return new ApiResponse(['error' => 'Route not found'], 404);
            }

            $route = $this->routes[$method][$path];

            // Instantiate controller
            $controllerClass = $route['controller'];
            $controller = $this->resolveController($controllerClass, $version);

            // Call action
            $action = $route['action'];
            $parameters = $this->extractParameters($path, $request->getPath());

            return $controller->$action($request, ...$parameters);

        } catch (Exception $e) {
            return new ApiResponse(['error' => 'Internal server error'], 500);
        }
    }

    private function determineVersion(Request $request): ApiVersionInterface
    {
        // Check Accept header for version
        $accept = $request->getHeader('Accept');

        if (strpos($accept, 'application/vnd.myapi.v2') !== false) {
            return new ApiV2();
        }

        // Check URL path for version
        $path = $request->getPath();
        if (preg_match('#^/api/v(\d+)#', $path, $matches)) {
            $versionNumber = $matches[1];

            switch ($versionNumber) {
                case '2':
                    return new ApiV2();
                default:
                    return new ApiV1();
            }
        }

        return $this->defaultVersion;
    }

    private function resolveController(string $controllerClass, ApiVersionInterface $version): object
    {
        // Use dependency injection container
        return Container::getInstance()->make($controllerClass, ['apiVersion' => $version]);
    }

    private function extractParameters(string $routePattern, string $actualPath): array
    {
        // Extract parameters from URL (e.g., /users/{id} -> /users/123)
        $routeParts = explode('/', trim($routePattern, '/'));
        $pathParts = explode('/', trim($actualPath, '/'));

        $parameters = [];
        foreach ($routeParts as $i => $part) {
            if (preg_match('/^\{(.+)\}$/', $part, $matches)) {
                $paramName = $matches[1];
                $parameters[] = $pathParts[$i] ?? null;
            }
        }

        return $parameters;
    }
}

class ContentNegotiator
{
    private array $supportedTypes = [
        'application/json',
        'application/vnd.api+json',
        'application/xml'
    ];

    public function getAcceptedContentType(): string
    {
        $acceptHeader = $_SERVER['HTTP_ACCEPT'] ?? 'application/json';

        // Parse Accept header and find best match
        $acceptTypes = explode(',', $acceptHeader);

        foreach ($acceptTypes as $type) {
            $type = trim(explode(';', $type)[0]); // Remove quality parameter

            if (in_array($type, $this->supportedTypes)) {
                return $type;
            }
        }

        return 'application/json'; // Default
    }

    public function negotiateContentType(array $supportedTypes): string
    {
        $accepted = $this->getAcceptedContentType();

        if (in_array($accepted, $supportedTypes)) {
            return $accepted;
        }

        return $supportedTypes[0] ?? 'application/json';
    }
}

// Version migration strategy
class ApiVersionMigrator
{
    private array $breakingChanges = [];

    public function __construct()
    {
        $this->breakingChanges = [
            'v1_to_v2' => [
                'user.email' => 'user.contact_email', // Field renamed
                'user.phone' => 'user.contact_phone', // Field renamed
                'orders.total' => 'orders.grand_total' // Field renamed
            ]
        ];
    }

    public function migrateData(array $data, string $fromVersion, string $toVersion): array
    {
        $migrationKey = $fromVersion . '_to_' . $toVersion;

        if (!isset($this->breakingChanges[$migrationKey])) {
            return $data; // No migration needed
        }

        $changes = $this->breakingChanges[$migrationKey];

        foreach ($changes as $oldPath => $newPath) {
            $value = $this->getValueByPath($data, $oldPath);
            if ($value !== null) {
                $this->setValueByPath($data, $newPath, $value);
                $this->unsetValueByPath($data, $oldPath);
            }
        }

        return $data;
    }

    private function getValueByPath(array $data, string $path)
    {
        $keys = explode('.', $path);
        $current = $data;

        foreach ($keys as $key) {
            if (!isset($current[$key])) {
                return null;
            }
            $current = $current[$key];
        }

        return $current;
    }

    private function setValueByPath(array &$data, string $path, $value): void
    {
        $keys = explode('.', $path);
        $current = &$data;

        foreach ($keys as $key) {
            if (!isset($current[$key])) {
                $current[$key] = [];
            }
            $current = &$current[$key];
        }

        $current = $value;
    }

    private function unsetValueByPath(array &$data, string $path): void
    {
        $keys = explode('.', $path);
        $lastKey = array_pop($keys);
        $current = &$data;

        foreach ($keys as $key) {
            if (!isset($current[$key])) {
                return;
            }
            $current = &$current[$key];
        }

        unset($current[$lastKey]);
    }
}

// API Documentation Generator
class ApiDocumentationGenerator
{
    private ApiRouter $router;
    private array $endpoints = [];

    public function __construct(ApiRouter $router)
    {
        $this->router = $router;
    }

    public function generateOpenAPISpec(): array
    {
        return [
            'openapi' => '3.0.1',
            'info' => [
                'title' => 'User Management API',
                'version' => '1.0.0',
                'description' => 'RESTful API for user management'
            ],
            'servers' => [
                ['url' => 'https://api.example.com/v1']
            ],
            'paths' => $this->generatePaths(),
            'components' => [
                'schemas' => $this->generateSchemas(),
                'securitySchemes' => [
                    'bearerAuth' => [
                        'type' => 'http',
                        'scheme' => 'bearer',
                        'bearerFormat' => 'JWT'
                    ]
                ]
            ],
            'security' => [
                ['bearerAuth' => []]
            ]
        ];
    }

    private function generatePaths(): array
    {
        return [
            '/users' => [
                'get' => [
                    'summary' => 'List users',
                    'parameters' => [
                        [
                            'name' => 'page',
                            'in' => 'query',
                            'schema' => ['type' => 'integer', 'default' => 1]
                        ],
                        [
                            'name' => 'limit',
                            'in' => 'query',
                            'schema' => ['type' => 'integer', 'default' => 20]
                        ]
                    ],
                    'responses' => [
                        '200' => [
                            'description' => 'Successful response',
                            'content' => [
                                'application/json' => [
                                    'schema' => [
                                        'type' => 'array',
                                        'items' => ['$ref' => '#/components/schemas/User']
                                    ]
                                ]
                            ]
                        ]
                    ]
                ],
                'post' => [
                    'summary' => 'Create user',
                    'requestBody' => [
                        'required' => true,
                        'content' => [
                            'application/json' => [
                                'schema' => ['$ref' => '#/components/schemas/UserInput']
                            ]
                        ]
                    ],
                    'responses' => [
                        '201' => [
                            'description' => 'User created',
                            'content' => [
                                'application/json' => [
                                    'schema' => ['$ref' => '#/components/schemas/User']
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ];
    }

    private function generateSchemas(): array
    {
        return [
            'User' => [
                'type' => 'object',
                'properties' => [
                    'id' => ['type' => 'string'],
                    'email' => ['type' => 'string', 'format' => 'email'],
                    'name' => ['type' => 'string'],
                    'created_at' => ['type' => 'string', 'format' => 'date-time'],
                    'is_active' => ['type' => 'boolean']
                ],
                'required' => ['id', 'email', 'name']
            ],
            'UserInput' => [
                'type' => 'object',
                'properties' => [
                    'email' => ['type' => 'string', 'format' => 'email'],
                    'name' => ['type' => 'string'],
                    'password' => ['type' => 'string', 'minLength' => 8]
                ],
                'required' => ['email', 'name', 'password']
            ]
        ];
    }
}

// Usage Example
$apiRouter = new ApiRouter(new ApiV1());

// Register routes
$apiRouter->addRoute('GET', '/users', UserController::class, 'index');
$apiRouter->addRoute('GET', '/users/{id}', UserController::class, 'show');
$apiRouter->addRoute('POST', '/users', UserController::class, 'store');
$apiRouter->addRoute('PUT', '/users/{id}', UserController::class, 'update');
$apiRouter->addRoute('DELETE', '/users/{id}', UserController::class, 'destroy');

// Handle request
$request = new Request(); // From framework
$response = $apiRouter->dispatch($request);

// Generate API documentation
$docsGenerator = new ApiDocumentationGenerator($apiRouter);
$openApiSpec = $docsGenerator->generateOpenAPISpec();

echo json_encode($openApiSpec, JSON_PRETTY_PRINT);
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">10</div>
                            <h3 class="question-title">Configuration Management for PHP Applications</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Configuration</span>
                            <span class="question-badge">Environment</span>
                            <span class="question-badge">Security</span>
                        </div>
                        <div class="question-content">
                            <p>Design a comprehensive configuration management system for PHP applications that supports multiple environments, secrets management, and runtime configuration updates.</p>

                            <div class="highlight-box warning">
                                <div class="highlight-header">
                                    <i class="fas fa-cogs highlight-icon"></i>
                                    <strong>Configuration Challenges:</strong>
                                </div>
                                <ul>
                                    <li><strong>Environment-specific settings:</strong> Dev, staging, production differences</li>
                                    <li><strong>Secrets management:</strong> API keys, passwords, certificates</li>
                                    <li><strong>Runtime updates:</strong> Change config without restarting</li>
                                    <li><strong>Validation:</strong> Ensure config values are valid and complete</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Configuration Management System
                        </button>

                        <div class="code-block" data-lang="php" data-title="Advanced Configuration Management System">
// Advanced Configuration Management System

interface ConfigurationProviderInterface
{
    public function get(string $key, $default = null);
    public function set(string $key, $value): void;
    public function has(string $key): bool;
    public function all(): array;
    public function load(): void;
    public function save(): void;
}

interface SecretsProviderInterface
{
    public function getSecret(string $key): ?string;
    public function setSecret(string $key, string $value): void;
    public function rotateSecret(string $key): string;
}

class ConfigurationManager
{
    private array $providers = [];
    private array $cache = [];
    private bool $cacheEnabled = true;
    private ConfigurationValidator $validator;
    private Logger $logger;

    public function __construct(ConfigurationValidator $validator, Logger $logger)
    {
        $this->validator = $validator;
        $this->logger = $logger;
    }

    public function addProvider(string $name, ConfigurationProviderInterface $provider, int $priority = 0): void
    {
        $this->providers[$name] = [
            'provider' => $provider,
            'priority' => $priority
        ];

        // Sort providers by priority (higher priority first)
        uasort($this->providers, fn($a, $b) => $b['priority'] <=> $a['priority']);
    }

    public function get(string $key, $default = null)
    {
        // Check cache first
        if ($this->cacheEnabled && isset($this->cache[$key])) {
            return $this->cache[$key];
        }

        // Search through providers in priority order
        foreach ($this->providers as $name => $providerData) {
            $provider = $providerData['provider'];

            if ($provider->has($key)) {
                $value = $provider->get($key);

                // Cache the value
                if ($this->cacheEnabled) {
                    $this->cache[$key] = $value;
                }

                $this->logger->debug("Configuration loaded", [
                    'key' => $key,
                    'provider' => $name,
                    'value_type' => gettype($value)
                ]);

                return $value;
            }
        }

        // Return default value
        if ($default !== null) {
            $this->logger->debug("Using default value for configuration", [
                'key' => $key,
                'default_type' => gettype($default)
            ]);
        }

        return $default;
    }

    public function set(string $key, $value): void
    {
        // Validate the configuration value
        if (!$this->validator->validate($key, $value)) {
            throw new ConfigurationException("Invalid configuration value for key: {$key}");
        }

        // Find the highest priority provider that supports writing
        foreach ($this->providers as $providerData) {
            $provider = $providerData['provider'];

            if (method_exists($provider, 'set')) {
                try {
                    $provider->set($key, $value);

                    // Update cache
                    if ($this->cacheEnabled) {
                        $this->cache[$key] = $value;
                    }

                    $this->logger->info("Configuration updated", ['key' => $key]);
                    return;
                } catch (Exception $e) {
                    $this->logger->warning("Failed to set configuration in provider", [
                        'key' => $key,
                        'provider' => get_class($provider),
                        'error' => $e->getMessage()
                    ]);
                }
            }
        }

        throw new ConfigurationException("No writable configuration provider available for key: {$key}");
    }

    public function loadAll(): void
    {
        foreach ($this->providers as $providerData) {
            $provider = $providerData['provider'];

            try {
                $provider->load();
                $this->logger->debug("Configuration provider loaded", [
                    'provider' => get_class($provider)
                ]);
            } catch (Exception $e) {
                $this->logger->error("Failed to load configuration provider", [
                    'provider' => get_class($provider),
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    public function saveAll(): void
    {
        foreach ($this->providers as $providerData) {
            $provider = $providerData['provider'];

            if (method_exists($provider, 'save')) {
                try {
                    $provider->save();
                    $this->logger->debug("Configuration provider saved", [
                        'provider' => get_class($provider)
                    ]);
                } catch (Exception $e) {
                    $this->logger->error("Failed to save configuration provider", [
                        'provider' => get_class($provider),
                        'error' => $e->getMessage()
                    ]);
                }
            }
        }
    }

    public function clearCache(): void
    {
        $this->cache = [];
        $this->logger->debug("Configuration cache cleared");
    }

    public function enableCache(): void
    {
        $this->cacheEnabled = true;
    }

    public function disableCache(): void
    {
        $this->cacheEnabled = false;
        $this->clearCache();
    }
}

class EnvironmentConfigurationProvider implements ConfigurationProviderInterface
{
    private array $config = [];
    private string $environment;

    public function __construct(string $environment = 'production')
    {
        $this->environment = $environment;
        $this->load();
    }

    public function load(): void
    {
        // Load environment-specific configuration files
        $files = [
            __DIR__ . '/config/default.php',
            __DIR__ . "/config/{$this->environment}.php",
            __DIR__ . '/config/local.php' // Local overrides (not in version control)
        ];

        foreach ($files as $file) {
            if (file_exists($file)) {
                $config = require $file;

                if (is_array($config)) {
                    $this->config = array_merge($this->config, $config);
                }
            }
        }
    }

    public function get(string $key, $default = null)
    {
        return $this->config[$key] ?? $default;
    }

    public function set(string $key, $value): void
    {
        $this->config[$key] = $value;
    }

    public function has(string $key): bool
    {
        return array_key_exists($key, $this->config);
    }

    public function all(): array
    {
        return $this->config;
    }

    public function save(): void
    {
        // Save to environment-specific file
        $file = __DIR__ . "/config/{$this->environment}.php";

        $content = "<?php\n\nreturn " . var_export($this->config, true) . ";\n";

        if (!file_put_contents($file, $content)) {
            throw new ConfigurationException("Failed to save configuration to: {$file}");
        }
    }
}

class DatabaseConfigurationProvider implements ConfigurationProviderInterface
{
    private PDO $pdo;
    private array $cache = [];
    private bool $loaded = false;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    public function load(): void
    {
        if ($this->loaded) {
            return;
        }

        $stmt = $this->pdo->query("SELECT config_key, config_value, data_type FROM configuration");

        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $value = $this->deserializeValue($row['config_value'], $row['data_type']);
            $this->cache[$row['config_key']] = $value;
        }

        $this->loaded = true;
    }

    public function get(string $key, $default = null)
    {
        $this->ensureLoaded();
        return $this->cache[$key] ?? $default;
    }

    public function set(string $key, $value): void
    {
        $this->ensureLoaded();

        $serialized = $this->serializeValue($value);
        $dataType = $this->getDataType($value);

        $stmt = $this->pdo->prepare("
            INSERT INTO configuration (config_key, config_value, data_type, updated_at)
            VALUES (?, ?, ?, NOW())
            ON DUPLICATE KEY UPDATE
            config_value = VALUES(config_value),
            data_type = VALUES(data_type),
            updated_at = NOW()
        ");

        $stmt->execute([$key, $serialized, $dataType]);
        $this->cache[$key] = $value;
    }

    public function has(string $key): bool
    {
        $this->ensureLoaded();
        return array_key_exists($key, $this->cache);
    }

    public function all(): array
    {
        $this->ensureLoaded();
        return $this->cache;
    }

    public function save(): void
    {
        // Database provider auto-saves on set()
    }

    private function ensureLoaded(): void
    {
        if (!$this->loaded) {
            $this->load();
        }
    }

    private function serializeValue($value): string
    {
        return serialize($value);
    }

    private function deserializeValue(string $value, string $dataType)
    {
        return unserialize($value);
    }

    private function getDataType($value): string
    {
        return gettype($value);
    }
}

class VaultSecretsProvider implements SecretsProviderInterface
{
    private string $vaultUrl;
    private string $token;
    private HttpClient $httpClient;
    private array $cache = [];

    public function __construct(string $vaultUrl, string $token)
    {
        $this->vaultUrl = $vaultUrl;
        $this->token = $token;
        $this->httpClient = new HttpClient();
    }

    public function getSecret(string $key): ?string
    {
        // Check cache first
        if (isset($this->cache[$key])) {
            return $this->cache[$key];
        }

        try {
            $response = $this->httpClient->get("{$this->vaultUrl}/v1/secret/{$key}", [], [
                'X-Vault-Token' => $this->token
            ]);

            if ($response['status'] === 200 && isset($response['data']['value'])) {
                $secret = $response['data']['value'];
                $this->cache[$key] = $secret; // Cache for performance
                return $secret;
            }
        } catch (Exception $e) {
            error_log("Failed to retrieve secret: {$key} - " . $e->getMessage());
        }

        return null;
    }

    public function setSecret(string $key, string $value): void
    {
        $response = $this->httpClient->post("{$this->vaultUrl}/v1/secret/{$key}", [
            'value' => $value
        ], [
            'X-Vault-Token' => $this->token
        ]);

        if ($response['status'] !== 200) {
            throw new SecretsException("Failed to store secret: {$key}");
        }

        // Update cache
        $this->cache[$key] = $value;
    }

    public function rotateSecret(string $key): string
    {
        // Generate new secret value
        $newSecret = bin2hex(random_bytes(32));

        // Store new secret
        $this->setSecret($key, $newSecret);

        // TODO: Update all systems that use this secret
        // This would involve calling APIs, updating config files, etc.

        return $newSecret;
    }
}

class ConfigurationValidator
{
    private array $rules = [];

    public function __construct()
    {
        $this->setupValidationRules();
    }

    public function addRule(string $key, callable $validator): void
    {
        $this->rules[$key] = $validator;
    }

    public function validate(string $key, $value): bool
    {
        // Check if there's a specific validator for this key
        if (isset($this->rules[$key])) {
            return $this->rules[$key]($value);
        }

        // Apply general validation based on key patterns
        return $this->validateByPattern($key, $value);
    }

    private function setupValidationRules(): void
    {
        // Database configuration
        $this->rules['database.host'] = function($value) {
            return is_string($value) && filter_var($value, FILTER_VALIDATE_IP) !== false;
        };

        $this->rules['database.port'] = function($value) {
            return is_int($value) && $value > 0 && $value <= 65535;
        };

        // Email configuration
        $this->rules['mail.smtp.host'] = function($value) {
            return is_string($value) && !empty($value);
        };

        $this->rules['mail.smtp.port'] = function($value) {
            return is_int($value) && in_array($value, [25, 465, 587, 2525]);
        };

        // Cache configuration
        $this->rules['cache.ttl'] = function($value) {
            return is_int($value) && $value > 0;
        };

        // API configuration
        $this->rules['api.rate_limit'] = function($value) {
            return is_int($value) && $value > 0 && $value <= 10000;
        };
    }

    private function validateByPattern(string $key, $value): bool
    {
        // Email validation
        if (strpos($key, 'email') !== false) {
            return filter_var($value, FILTER_VALIDATE_EMAIL) !== false;
        }

        // URL validation
        if (strpos($key, 'url') !== false || strpos($key, 'endpoint') !== false) {
            return filter_var($value, FILTER_VALIDATE_URL) !== false;
        }

        // Port validation
        if (strpos($key, 'port') !== false) {
            return is_int($value) && $value > 0 && $value <= 65535;
        }

        // Timeout validation
        if (strpos($key, 'timeout') !== false) {
            return is_numeric($value) && $value > 0 && $value <= 300;
        }

        // Boolean validation for enabled/disabled flags
        if (strpos($key, 'enabled') !== false || strpos($key, 'disabled') !== false) {
            return is_bool($value);
        }

        // Default: accept any non-empty value
        return !empty($value);
    }
}

class ConfigurationHotReload
{
    private ConfigurationManager $configManager;
    private array $watchers = [];
    private bool $enabled = false;

    public function __construct(ConfigurationManager $configManager)
    {
        $this->configManager = $configManager;
    }

    public function enable(): void
    {
        $this->enabled = true;
        $this->setupFileWatchers();
        $this->setupDatabaseWatcher();
    }

    public function disable(): void
    {
        $this->enabled = false;
        $this->watchers = [];
    }

    private function setupFileWatchers(): void
    {
        $configFiles = [
            __DIR__ . '/config/default.php',
            __DIR__ . '/config/production.php',
            __DIR__ . '/config/staging.php'
        ];

        foreach ($configFiles as $file) {
            if (file_exists($file)) {
                $this->watchers[] = new FileWatcher($file, function() {
                    if ($this->enabled) {
                        $this->configManager->clearCache();
                        $this->configManager->loadAll();
                    }
                });
            }
        }
    }

    private function setupDatabaseWatcher(): void
    {
        // In a real implementation, this would use database triggers
        // or periodic polling to detect configuration changes
        $this->watchers[] = new DatabaseWatcher(function() {
            if ($this->enabled) {
                $this->configManager->clearCache();
            }
        });
    }
}

// Usage Example
$configManager = new ConfigurationManager(
    new ConfigurationValidator(),
    new Logger('config')
);

// Add configuration providers (in order of priority)
$configManager->addProvider('environment', new EnvironmentConfigurationProvider('production'), 10);
$configManager->addProvider('database', new DatabaseConfigurationProvider($pdo), 5);

// Add secrets provider
$secretsProvider = new VaultSecretsProvider(
    getenv('VAULT_URL'),
    getenv('VAULT_TOKEN')
);

// Load all configuration
$configManager->loadAll();

// Enable hot reload for development
if (getenv('APP_ENV') === 'development') {
    $hotReload = new ConfigurationHotReload($configManager);
    $hotReload->enable();
}

// Usage throughout application
$dbHost = $configManager->get('database.host', 'localhost');
$dbPort = $configManager->get('database.port', 3306);
$apiKey = $secretsProvider->getSecret('stripe.api_key');

$smtpConfig = [
    'host' => $configManager->get('mail.smtp.host'),
    'port' => $configManager->get('mail.smtp.port'),
    'username' => $secretsProvider->getSecret('smtp.username'),
    'password' => $secretsProvider->getSecret('smtp.password')
];

// Dynamic configuration updates
$configManager->set('api.rate_limit', 1000);
$configManager->saveAll();
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">11</div>
                            <h3 class="question-title">Deployment Strategies and Blue-Green Deployments</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Deployment</span>
                            <span class="question-badge">DevOps</span>
                            <span class="question-badge">Zero Downtime</span>
                        </div>
                        <div class="question-content">
                            <p>Design and implement blue-green deployment strategy for PHP applications with automated rollback capabilities, health checks, and traffic management.</p>

                            <div class="highlight-box success">
                                <div class="highlight-header">
                                    <i class="fas fa-ship highlight-icon"></i>
                                    <strong>Blue-Green Deployment Benefits:</strong>
                                </div>
                                <ul>
                                    <li><strong>Zero Downtime:</strong> Switch traffic instantly between versions</li>
                                    <li><strong>Instant Rollback:</strong> Switch back to previous version immediately</li>
                                    <li><strong>Risk Reduction:</strong> Test new version with real traffic before full rollout</li>
                                    <li><strong>Gradual Rollout:</strong> Canary deployments and A/B testing</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Blue-Green Deployment System
                        </button>

                        <div class="code-block" data-lang="php" data-title="Blue-Green Deployment Implementation">
// Blue-Green Deployment System for PHP Applications

interface DeploymentStrategyInterface
{
    public function deploy(DeploymentPackage $package): DeploymentResult;
    public function rollback(string $deploymentId): bool;
    public function getStatus(string $deploymentId): DeploymentStatus;
}

interface LoadBalancerInterface
{
    public function switchTraffic(string $fromEnvironment, string $toEnvironment): bool;
    public function getTrafficDistribution(): array;
    public function enableCanary(string $environment, float $percentage): bool;
}

class DeploymentPackage
{
    public string $version;
    public string $artifactPath;
    public array $environmentConfig;
    public array $migrations;
    public array $healthChecks;

    public function __construct(string $version, string $artifactPath)
    {
        $this->version = $version;
        $this->artifactPath = $artifactPath;
        $this->environmentConfig = [];
        $this->migrations = [];
        $this->healthChecks = [];
    }
}

class DeploymentResult
{
    public bool $success;
    public string $deploymentId;
    public string $message;
    public array $metadata;

    public function __construct(bool $success, string $deploymentId, string $message = '', array $metadata = [])
    {
        $this->success = $success;
        $this->deploymentId = $deploymentId;
        $this->message = $message;
        $this->metadata = $metadata;
    }
}

enum DeploymentStatus
{
    case PENDING;
    case IN_PROGRESS;
    case HEALTH_CHECKING;
    case READY;
    case LIVE;
    case FAILED;
    case ROLLED_BACK;
}

class BlueGreenDeployment implements DeploymentStrategyInterface
{
    private LoadBalancerInterface $loadBalancer;
    private HealthChecker $healthChecker;
    private DatabaseManager $dbManager;
    private FileSystem $fileSystem;
    private Logger $logger;

    private array $environments = [
        'blue' => ['path' => '/var/www/blue', 'active' => true],
        'green' => ['path' => '/var/www/green', 'active' => false]
    ];

    public function __construct(
        LoadBalancerInterface $loadBalancer,
        HealthChecker $healthChecker,
        DatabaseManager $dbManager,
        Logger $logger
    ) {
        $this->loadBalancer = $loadBalancer;
        $this->healthChecker = $healthChecker;
        $this->dbManager = $dbManager;
        $this->logger = $logger;
        $this->fileSystem = new FileSystem();
    }

    public function deploy(DeploymentPackage $package): DeploymentResult
    {
        $deploymentId = uniqid('deploy_', true);
        $inactiveEnv = $this->getInactiveEnvironment();

        $this->logger->info("Starting blue-green deployment", [
            'deployment_id' => $deploymentId,
            'version' => $package->version,
            'target_env' => $inactiveEnv
        ]);

        try {
            // Step 1: Prepare the inactive environment
            $this->prepareEnvironment($inactiveEnv, $package);

            // Step 2: Run database migrations
            $this->runMigrations($package);

            // Step 3: Deploy the application
            $this->deployApplication($inactiveEnv, $package);

            // Step 4: Run health checks
            if (!$this->runHealthChecks($inactiveEnv, $package->healthChecks)) {
                throw new DeploymentException("Health checks failed for environment: {$inactiveEnv}");
            }

            // Step 5: Switch traffic (canary deployment first)
            $this->performCanaryDeployment($inactiveEnv);

            // Step 6: Full traffic switch if canary succeeds
            $this->switchTraffic($inactiveEnv);

            $this->logger->info("Deployment completed successfully", [
                'deployment_id' => $deploymentId,
                'environment' => $inactiveEnv
            ]);

            return new DeploymentResult(true, $deploymentId, 'Deployment completed successfully', [
                'environment' => $inactiveEnv,
                'version' => $package->version
            ]);

        } catch (Exception $e) {
            $this->logger->error("Deployment failed", [
                'deployment_id' => $deploymentId,
                'error' => $e->getMessage()
            ]);

            // Attempt automatic rollback
            try {
                $this->rollback($deploymentId);
            } catch (Exception $rollbackError) {
                $this->logger->error("Rollback also failed", [
                    'deployment_id' => $deploymentId,
                    'error' => $rollbackError->getMessage()
                ]);
            }

            return new DeploymentResult(false, $deploymentId, $e->getMessage());
        }
    }

    public function rollback(string $deploymentId): bool
    {
        $activeEnv = $this->getActiveEnvironment();
        $inactiveEnv = $this->getInactiveEnvironment();

        $this->logger->info("Starting rollback", [
            'deployment_id' => $deploymentId,
            'from_env' => $activeEnv,
            'to_env' => $inactiveEnv
        ]);

        try {
            // Switch traffic back to the inactive environment
            $this->loadBalancer->switchTraffic($activeEnv, $inactiveEnv);

            // Update environment status
            $this->environments[$activeEnv]['active'] = false;
            $this->environments[$inactiveEnv]['active'] = true;

            // Rollback database migrations if needed
            $this->rollbackMigrations();

            $this->logger->info("Rollback completed successfully", [
                'deployment_id' => $deploymentId
            ]);

            return true;

        } catch (Exception $e) {
            $this->logger->error("Rollback failed", [
                'deployment_id' => $deploymentId,
                'error' => $e->getMessage()
            ]);

            return false;
        }
    }

    public function getStatus(string $deploymentId): DeploymentStatus
    {
        // In a real implementation, this would track deployment status in a database
        // For simplicity, we'll return a mock status
        return DeploymentStatus::LIVE;
    }

    private function getActiveEnvironment(): string
    {
        foreach ($this->environments as $env => $config) {
            if ($config['active']) {
                return $env;
            }
        }
        return 'blue'; // Default
    }

    private function getInactiveEnvironment(): string
    {
        foreach ($this->environments as $env => $config) {
            if (!$config['active']) {
                return $env;
            }
        }
        return 'green'; // Default
    }

    private function prepareEnvironment(string $environment, DeploymentPackage $package): void
    {
        $envPath = $this->environments[$environment]['path'];

        $this->logger->info("Preparing environment", [
            'environment' => $environment,
            'path' => $envPath
        ]);

        // Create backup of current environment
        $backupPath = $envPath . '_backup_' . date('Y-m-d_H-i-s');
        $this->fileSystem->copyDirectory($envPath, $backupPath);

        // Clean the environment directory
        $this->fileSystem->cleanDirectory($envPath);

        // Extract deployment package
        $this->fileSystem->extractArchive($package->artifactPath, $envPath);

        // Apply environment-specific configuration
        $this->applyEnvironmentConfig($environment, $package->environmentConfig);
    }

    private function runMigrations(DeploymentPackage $package): void
    {
        if (!empty($package->migrations)) {
            $this->logger->info("Running database migrations", [
                'migration_count' => count($package->migrations)
            ]);

            foreach ($package->migrations as $migration) {
                $this->dbManager->runMigration($migration);
            }
        }
    }

    private function deployApplication(string $environment, DeploymentPackage $package): void
    {
        $envPath = $this->environments[$environment]['path'];

        $this->logger->info("Deploying application", [
            'environment' => $environment,
            'version' => $package->version
        ]);

        // Set proper permissions
        $this->fileSystem->setPermissions($envPath . '/storage', 0755);
        $this->fileSystem->setPermissions($envPath . '/bootstrap/cache', 0755);

        // Clear any cached files
        $this->clearApplicationCache($envPath);

        // Warm up caches if needed
        $this->warmUpApplicationCache($envPath);
    }

    private function runHealthChecks(string $environment, array $healthChecks): bool
    {
        $envPath = $this->environments[$environment]['path'];

        $this->logger->info("Running health checks", [
            'environment' => $environment,
            'checks_count' => count($healthChecks)
        ]);

        foreach ($healthChecks as $check) {
            if (!$this->healthChecker->runCheck($check, $envPath)) {
                $this->logger->error("Health check failed", [
                    'environment' => $environment,
                    'check' => $check
                ]);
                return false;
            }
        }

        return true;
    }

    private function performCanaryDeployment(string $environment): void
    {
        // Start with 5% of traffic
        $canaryPercentage = 5.0;

        $this->logger->info("Starting canary deployment", [
            'environment' => $environment,
            'percentage' => $canaryPercentage
        ]);

        $this->loadBalancer->enableCanary($environment, $canaryPercentage);

        // Monitor canary for 5 minutes
        $monitoringDuration = 300; // 5 minutes
        $startTime = time();

        while (time() - $startTime < $monitoringDuration) {
            $metrics = $this->healthChecker->getMetrics($environment);

            // Check if canary is healthy
            if (!$this->isCanaryHealthy($metrics)) {
                throw new DeploymentException("Canary deployment failed - rolling back");
            }

            sleep(30); // Check every 30 seconds
        }

        $this->logger->info("Canary deployment successful", [
            'environment' => $environment
        ]);
    }

    private function switchTraffic(string $newEnvironment): void
    {
        $oldEnvironment = $this->getActiveEnvironment();

        $this->logger->info("Switching traffic", [
            'from' => $oldEnvironment,
            'to' => $newEnvironment
        ]);

        // Perform the traffic switch
        $this->loadBalancer->switchTraffic($oldEnvironment, $newEnvironment);

        // Update environment status
        $this->environments[$oldEnvironment]['active'] = false;
        $this->environments[$newEnvironment]['active'] = true;

        // Wait for traffic to fully switch
        sleep(10);

        // Verify the switch was successful
        $distribution = $this->loadBalancer->getTrafficDistribution();

        if ($distribution[$newEnvironment] < 95) { // Less than 95% traffic switched
            throw new DeploymentException("Traffic switch verification failed");
        }
    }

    private function isCanaryHealthy(array $metrics): bool
    {
        // Check various health metrics
        $errorRate = $metrics['error_rate'] ?? 0;
        $responseTime = $metrics['avg_response_time'] ?? 0;
        $cpuUsage = $metrics['cpu_usage'] ?? 0;

        return $errorRate < 5 && $responseTime < 2000 && $cpuUsage < 80;
    }

    private function applyEnvironmentConfig(string $environment, array $config): void
    {
        // Apply environment-specific configuration
        // This would typically update .env files or config files
    }

    private function clearApplicationCache(string $path): void
    {
        // Clear Laravel caches, etc.
        $cacheDirs = [
            $path . '/storage/framework/cache',
            $path . '/storage/framework/views',
            $path . '/bootstrap/cache'
        ];

        foreach ($cacheDirs as $dir) {
            if (is_dir($dir)) {
                $this->fileSystem->cleanDirectory($dir);
            }
        }
    }

    private function warmUpApplicationCache(string $path): void
    {
        // Run application commands to warm up caches
        // This would typically run Laravel's cache warming commands
    }

    private function rollbackMigrations(): void
    {
        // Rollback the most recent migrations
        $this->dbManager->rollbackMigrations(1);
    }
}

class NginxLoadBalancer implements LoadBalancerInterface
{
    private string $configPath;
    private CommandRunner $commandRunner;

    public function __construct(string $configPath = '/etc/nginx/sites-enabled')
    {
        $this->configPath = $configPath;
        $this->commandRunner = new CommandRunner();
    }

    public function switchTraffic(string $fromEnvironment, string $toEnvironment): bool
    {
        // Update nginx upstream configuration
        $config = $this->generateUpstreamConfig($toEnvironment);
        file_put_contents($this->configPath . '/upstream.conf', $config);

        // Reload nginx configuration
        $result = $this->commandRunner->run('nginx -t && nginx -s reload');

        return $result['success'];
    }

    public function getTrafficDistribution(): array
    {
        // In a real implementation, this would query nginx stats or logs
        // For simplicity, return mock data
        return [
            'blue' => 5,
            'green' => 95
        ];
    }

    public function enableCanary(string $environment, float $percentage): bool
    {
        // Configure nginx for canary deployment
        $config = $this->generateCanaryConfig($environment, $percentage);
        file_put_contents($this->configPath . '/canary.conf', $config);

        $result = $this->commandRunner->run('nginx -t && nginx -s reload');

        return $result['success'];
    }

    private function generateUpstreamConfig(string $activeEnvironment): string
    {
        $blueServers = ['blue1.example.com', 'blue2.example.com'];
        $greenServers = ['green1.example.com', 'green2.example.com'];

        $servers = ($activeEnvironment === 'blue') ? $blueServers : $greenServers;

        $config = "upstream app_servers {\n";
        foreach ($servers as $server) {
            $config .= "    server {$server}:80;\n";
        }
        $config .= "}\n";

        return $config;
    }

    private function generateCanaryConfig(string $canaryEnvironment, float $percentage): string
    {
        $mainPercentage = 100 - $percentage;

        return "
        split_clients \$request_id \$canary_test {
            {$mainPercentage}%     production;
            {$percentage}%          canary;
        }

        upstream production_servers {
            server blue1.example.com:80;
            server blue2.example.com:80;
        }

        upstream canary_servers {
            server {$canaryEnvironment}1.example.com:80;
            server {$canaryEnvironment}2.example.com:80;
        }
        ";
    }
}

class HealthChecker
{
    private HttpClient $httpClient;
    private Logger $logger;

    public function __construct(HttpClient $httpClient, Logger $logger)
    {
        $this->httpClient = $httpClient;
        $this->logger = $logger;
    }

    public function runCheck(array $check, string $baseUrl): bool
    {
        $url = $baseUrl . $check['endpoint'];
        $method = $check['method'] ?? 'GET';
        $expectedStatus = $check['expected_status'] ?? 200;
        $timeout = $check['timeout'] ?? 30;

        try {
            $response = $this->httpClient->request($method, $url, [], [], $timeout);

            if ($response['status'] === $expectedStatus) {
                $this->logger->info("Health check passed", [
                    'endpoint' => $check['endpoint'],
                    'status' => $response['status']
                ]);
                return true;
            } else {
                $this->logger->error("Health check failed", [
                    'endpoint' => $check['endpoint'],
                    'expected' => $expectedStatus,
                    'actual' => $response['status']
                ]);
                return false;
            }
        } catch (Exception $e) {
            $this->logger->error("Health check error", [
                'endpoint' => $check['endpoint'],
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    public function getMetrics(string $environment): array
    {
        // In a real implementation, this would query monitoring systems
        // like Prometheus, New Relic, or DataDog
        return [
            'error_rate' => 2.1,
            'avg_response_time' => 450,
            'cpu_usage' => 35,
            'memory_usage' => 60
        ];
    }
}

// Usage Example
$deployment = new BlueGreenDeployment(
    new NginxLoadBalancer(),
    new HealthChecker(new HttpClient(), new Logger('health')),
    new DatabaseManager(),
    new Logger('deployment')
);

// Create deployment package
$package = new DeploymentPackage('1.2.3', '/path/to/artifact.tar.gz');
$package->migrations = ['add_user_preferences_table'];
$package->healthChecks = [
    ['endpoint' => '/health', 'expected_status' => 200],
    ['endpoint' => '/api/status', 'expected_status' => 200]
];

// Deploy
$result = $deployment->deploy($package);

if ($result->success) {
    echo "Deployment successful! Environment: {$result->metadata['environment']}\n";
} else {
    echo "Deployment failed: {$result->message}\n";

    // Rollback if needed
    $deployment->rollback($result->deploymentId);
}
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">12</div>
                            <h3 class="question-title">Monitoring and Alerting for PHP Applications</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Monitoring</span>
                            <span class="question-badge">Alerting</span>
                            <span class="question-badge">Observability</span>
                        </div>
                        <div class="question-content">
                            <p>Design comprehensive monitoring and alerting systems for PHP applications including metrics collection, log aggregation, distributed tracing, and automated incident response.</p>

                            <div class="highlight-box info">
                                <div class="highlight-header">
                                    <i class="fas fa-chart-line highlight-icon"></i>
                                    <strong>Observability Pillars:</strong>
                                </div>
                                <ul>
                                    <li><strong>Metrics:</strong> Quantitative measurements (response times, error rates, throughput)</li>
                                    <li><strong>Logs:</strong> Structured events and debugging information</li>
                                    <li><strong>Traces:</strong> Request flow through distributed systems</li>
                                    <li><strong>Alerts:</strong> Proactive notifications of issues</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Monitoring and Alerting System
                        </button>

                        <div class="code-block" data-lang="php" data-title="Comprehensive Monitoring and Alerting System">
// Comprehensive Monitoring and Alerting System

interface MetricsCollectorInterface
{
    public function increment(string $metric, array $tags = [], float $value = 1.0): void;
    public function gauge(string $metric, float $value, array $tags = []): void;
    public function histogram(string $metric, float $value, array $tags = []): void;
    public function timing(string $metric, float $duration, array $tags = []): void;
}

interface AlertManagerInterface
{
    public function alert(string $alertName, string $message, array $context = []): void;
    public function resolve(string $alertName): void;
    public function getActiveAlerts(): array;
}

class MonitoringSystem
{
    private MetricsCollectorInterface $metrics;
    private Logger $logger;
    private AlertManagerInterface $alertManager;
    private array $thresholds;

    public function __construct(
        MetricsCollectorInterface $metrics,
        Logger $logger,
        AlertManagerInterface $alertManager
    ) {
        $this->metrics = $metrics;
        $this->logger = $logger;
        $this->alertManager = $alertManager;
        $this->setupThresholds();
    }

    private function setupThresholds(): void
    {
        $this->thresholds = [
            'response_time_p95' => ['warning' => 2000, 'critical' => 5000], // ms
            'error_rate' => ['warning' => 5, 'critical' => 10], // percentage
            'memory_usage' => ['warning' => 80, 'critical' => 95], // percentage
            'cpu_usage' => ['warning' => 70, 'critical' => 90], // percentage
            'disk_usage' => ['warning' => 85, 'critical' => 95], // percentage
            'db_connection_pool' => ['warning' => 80, 'critical' => 95], // percentage used
        ];
    }

    public function recordHttpRequest(string $method, string $endpoint, float $duration, int $statusCode): void
    {
        $tags = [
            'method' => $method,
            'endpoint' => $endpoint,
            'status' => (string) $statusCode,
            'status_group' => $this->getStatusGroup($statusCode)
        ];

        // Record request count
        $this->metrics->increment('http_requests_total', $tags);

        // Record response time
        $this->metrics->histogram('http_request_duration', $duration, $tags);

        // Check for slow requests
        if ($duration > 3000) { // 3 seconds
            $this->alertManager->alert(
                'slow_request',
                "Slow request detected: {$method} {$endpoint} took {$duration}ms",
                ['method' => $method, 'endpoint' => $endpoint, 'duration' => $duration]
            );
        }

        // Check for high error rates
        if ($statusCode >= 500) {
            $this->checkErrorRate('http_5xx_errors');
        }
    }

    public function recordDatabaseQuery(string $query, float $duration, bool $success = true): void
    {
        $tags = [
            'success' => $success ? 'true' : 'false',
            'query_type' => $this->getQueryType($query)
        ];

        $this->metrics->increment('db_queries_total', $tags);
        $this->metrics->histogram('db_query_duration', $duration, $tags);

        // Alert on slow queries
        if ($duration > 1000) { // 1 second
            $this->logger->warning('Slow database query', [
                'query' => $this->sanitizeQuery($query),
                'duration' => $duration
            ]);

            $this->alertManager->alert(
                'slow_db_query',
                "Slow database query detected: {$duration}ms",
                ['query_type' => $tags['query_type'], 'duration' => $duration]
            );
        }
    }

    public function recordSystemMetrics(): void
    {
        $memoryUsage = $this->getMemoryUsage();
        $cpuUsage = $this->getCpuUsage();
        $diskUsage = $this->getDiskUsage();

        $this->metrics->gauge('system_memory_usage_percent', $memoryUsage);
        $this->metrics->gauge('system_cpu_usage_percent', $cpuUsage);
        $this->metrics->gauge('system_disk_usage_percent', $diskUsage);

        // Check thresholds and alert
        $this->checkThreshold('memory_usage', $memoryUsage);
        $this->checkThreshold('cpu_usage', $cpuUsage);
        $this->checkThreshold('disk_usage', $diskUsage);
    }

    public function recordBusinessMetrics(string $event, array $context = []): void
    {
        $tags = array_merge($context, ['event' => $event]);

        $this->metrics->increment('business_events_total', $tags);

        // Business-specific alerting
        switch ($event) {
            case 'user_registration':
                // Track registration rate
                break;
            case 'payment_failed':
                $this->alertManager->alert(
                    'payment_failures',
                    'Payment failure detected',
                    $context
                );
                break;
            case 'order_completed':
                // Track conversion rates
                break;
        }
    }

    public function checkApplicationHealth(): array
    {
        $health = [
            'status' => 'healthy',
            'checks' => [],
            'timestamp' => time()
        ];

        // Database connectivity
        $dbHealth = $this->checkDatabaseHealth();
        $health['checks']['database'] = $dbHealth;

        // External services
        $health['checks']['external_services'] = $this->checkExternalServices();

        // Application-specific checks
        $health['checks']['application'] = $this->checkApplicationSpecific();

        // Determine overall health
        foreach ($health['checks'] as $check) {
            if ($check['status'] !== 'healthy') {
                $health['status'] = 'unhealthy';
                break;
            }
        }

        // Alert if unhealthy
        if ($health['status'] !== 'healthy') {
            $this->alertManager->alert(
                'application_unhealthy',
                'Application health check failed',
                ['health_data' => $health]
            );
        }

        return $health;
    }

    private function checkThreshold(string $metric, float $value): void
    {
        if (!isset($this->thresholds[$metric])) {
            return;
        }

        $thresholds = $this->thresholds[$metric];

        if ($value >= $thresholds['critical']) {
            $this->alertManager->alert(
                "high_{$metric}",
                "Critical: {$metric} is {$value}% (threshold: {$thresholds['critical']}%)",
                ['metric' => $metric, 'value' => $value, 'level' => 'critical']
            );
        } elseif ($value >= $thresholds['warning']) {
            $this->alertManager->alert(
                "high_{$metric}",
                "Warning: {$metric} is {$value}% (threshold: {$thresholds['warning']}%)",
                ['metric' => $metric, 'value' => $value, 'level' => 'warning']
            );
        }
    }

    private function checkErrorRate(string $metric): void
    {
        // Calculate error rate over last 5 minutes
        // This would typically use a time-series database
        $errorRate = $this->calculateErrorRate($metric);

        if ($errorRate > 10) { // 10% error rate
            $this->alertManager->alert(
                'high_error_rate',
                "High error rate detected: {$errorRate}%",
                ['error_rate' => $errorRate, 'metric' => $metric]
            );
        }
    }

    private function getStatusGroup(int $statusCode): string
    {
        if ($statusCode >= 200 && $statusCode < 300) return '2xx';
        if ($statusCode >= 300 && $statusCode < 400) return '3xx';
        if ($statusCode >= 400 && $statusCode < 500) return '4xx';
        if ($statusCode >= 500 && $statusCode < 600) return '5xx';
        return 'unknown';
    }

    private function getQueryType(string $query): string
    {
        $query = strtoupper(trim($query));

        if (strpos($query, 'SELECT') === 0) return 'SELECT';
        if (strpos($query, 'INSERT') === 0) return 'INSERT';
        if (strpos($query, 'UPDATE') === 0) return 'UPDATE';
        if (strpos($query, 'DELETE') === 0) return 'DELETE';

        return 'OTHER';
    }

    private function sanitizeQuery(string $query): string
    {
        // Remove sensitive data from query for logging
        // This is a simplified example
        return preg_replace('/(PASSWORD|TOKEN|KEY)\s*=\s*[\'"][^\'"]*[\'"]/', '$1=***', $query);
    }

    private function getMemoryUsage(): float
    {
        return (memory_get_usage(true) / $this->getMemoryLimit()) * 100;
    }

    private function getCpuUsage(): float
    {
        // Simplified CPU usage calculation
        // In production, you'd use system calls or monitoring agents
        return rand(10, 90); // Mock data
    }

    private function getDiskUsage(): float
    {
        $diskTotal = disk_total_space('/');
        $diskFree = disk_free_space('/');
        $diskUsed = $diskTotal - $diskFree;

        return ($diskUsed / $diskTotal) * 100;
    }

    private function getMemoryLimit(): int
    {
        $limit = ini_get('memory_limit');
        return $this->convertToBytes($limit);
    }

    private function convertToBytes(string $size): int
    {
        $unit = strtolower(substr($size, -1));
        $value = (int) substr($size, 0, -1);

        switch ($unit) {
            case 'g': return $value * 1024 * 1024 * 1024;
            case 'm': return $value * 1024 * 1024;
            case 'k': return $value * 1024;
            default: return $value;
        }
    }

    private function calculateErrorRate(string $metric): float
    {
        // Simplified error rate calculation
        // In production, this would query metrics over time
        return rand(0, 15); // Mock data
    }

    private function checkDatabaseHealth(): array
    {
        try {
            $pdo = new PDO("mysql:host=localhost;dbname=test", "user", "pass");
            $stmt = $pdo->query("SELECT 1");
            $stmt->fetch();

            return ['status' => 'healthy', 'response_time' => 50];
        } catch (Exception $e) {
            return ['status' => 'unhealthy', 'error' => $e->getMessage()];
        }
    }

    private function checkExternalServices(): array
    {
        $services = [
            'payment_gateway' => 'https://api.paymentgateway.com/health',
            'email_service' => 'https://api.emailservice.com/status',
            'cdn' => 'https://cdn.example.com/ping'
        ];

        $results = [];

        foreach ($services as $name => $url) {
            try {
                $httpClient = new HttpClient();
                $response = $httpClient->get($url, [], [], 5); // 5 second timeout

                $results[$name] = [
                    'status' => $response['status'] === 200 ? 'healthy' : 'unhealthy',
                    'response_time' => $response['response_time'] ?? 0
                ];
            } catch (Exception $e) {
                $results[$name] = [
                    'status' => 'unhealthy',
                    'error' => $e->getMessage()
                ];
            }
        }

        return $results;
    }

    private function checkApplicationSpecific(): array
    {
        // Application-specific health checks
        $checks = [
            'cache' => $this->checkCacheHealth(),
            'queue' => $this->checkQueueHealth(),
            'sessions' => $this->checkSessionHealth()
        ];

        return $checks;
    }

    private function checkCacheHealth(): array
    {
        try {
            $cache = new Redis();
            $cache->connect('localhost', 6379);
            $cache->ping();

            return ['status' => 'healthy'];
        } catch (Exception $e) {
            return ['status' => 'unhealthy', 'error' => $e->getMessage()];
        }
    }

    private function checkQueueHealth(): array
    {
        // Check queue length and processing rate
        $queueLength = $this->getQueueLength();
        $processingRate = $this->getQueueProcessingRate();

        if ($queueLength > 1000) {
            $this->alertManager->alert(
                'queue_backlog',
                "Queue backlog detected: {$queueLength} messages",
                ['queue_length' => $queueLength]
            );

            return ['status' => 'warning', 'queue_length' => $queueLength];
        }

        return ['status' => 'healthy', 'queue_length' => $queueLength, 'processing_rate' => $processingRate];
    }

    private function checkSessionHealth(): array
    {
        // Check session storage health
        $sessionCount = $this->getActiveSessionCount();

        if ($sessionCount > 10000) { // High session count
            return ['status' => 'warning', 'active_sessions' => $sessionCount];
        }

        return ['status' => 'healthy', 'active_sessions' => $sessionCount];
    }

    private function getQueueLength(): int
    {
        // Mock queue length
        return rand(0, 2000);
    }

    private function getQueueProcessingRate(): float
    {
        // Mock processing rate (messages per second)
        return rand(50, 200);
    }

    private function getActiveSessionCount(): int
    {
        // Mock session count
        return rand(100, 15000);
    }
}

class PrometheusMetricsCollector implements MetricsCollectorInterface
{
    private string $gatewayUrl;
    private array $buffer = [];

    public function __construct(string $gatewayUrl)
    {
        $this->gatewayUrl = $gatewayUrl;
    }

    public function increment(string $metric, array $tags = [], float $value = 1.0): void
    {
        $this->buffer[] = [
            'metric' => $metric,
            'type' => 'counter',
            'value' => $value,
            'tags' => $tags,
            'timestamp' => time()
        ];

        $this->flushIfNeeded();
    }

    public function gauge(string $metric, float $value, array $tags = []): void
    {
        $this->buffer[] = [
            'metric' => $metric,
            'type' => 'gauge',
            'value' => $value,
            'tags' => $tags,
            'timestamp' => time()
        ];

        $this->flushIfNeeded();
    }

    public function histogram(string $metric, float $value, array $tags = []): void
    {
        $this->buffer[] = [
            'metric' => $metric,
            'type' => 'histogram',
            'value' => $value,
            'tags' => $tags,
            'timestamp' => time()
        ];

        $this->flushIfNeeded();
    }

    public function timing(string $metric, float $duration, array $tags = []): void
    {
        // Convert duration to seconds for Prometheus
        $this->histogram($metric . '_duration_seconds', $duration / 1000, $tags);
    }

    private function flushIfNeeded(): void
    {
        if (count($this->buffer) >= 100) { // Flush every 100 metrics
            $this->flush();
        }
    }

    private function flush(): void
    {
        if (empty($this->buffer)) {
            return;
        }

        try {
            $httpClient = new HttpClient();
            $response = $httpClient->post($this->gatewayUrl . '/metrics', [
                'metrics' => $this->buffer
            ]);

            if ($response['status'] === 200) {
                $this->buffer = []; // Clear buffer on success
            }
        } catch (Exception $e) {
            // Log error but don't throw - monitoring shouldn't break the app
            error_log("Failed to send metrics to Prometheus: " . $e->getMessage());
        }
    }

    public function __destruct()
    {
        $this->flush(); // Final flush
    }
}

class AlertManager implements AlertManagerInterface
{
    private array $activeAlerts = [];
    private array $notificationChannels = [];
    private Logger $logger;

    public function __construct(Logger $logger)
    {
        $this->logger = $logger;
        $this->setupNotificationChannels();
    }

    private function setupNotificationChannels(): void
    {
        $this->notificationChannels = [
            'slack' => new SlackNotifier(getenv('SLACK_WEBHOOK_URL')),
            'email' => new EmailNotifier(),
            'sms' => new SMSNotifier(),
            'pagerduty' => new PagerDutyNotifier(getenv('PAGERDUTY_API_KEY'))
        ];
    }

    public function alert(string $alertName, string $message, array $context = []): void
    {
        // Check if alert is already active
        if (isset($this->activeAlerts[$alertName])) {
            // Update existing alert
            $this->activeAlerts[$alertName]['last_seen'] = time();
            $this->activeAlerts[$alertName]['count']++;
            return;
        }

        // Create new alert
        $alert = [
            'name' => $alertName,
            'message' => $message,
            'context' => $context,
            'created_at' => time(),
            'last_seen' => time(),
            'count' => 1,
            'severity' => $this->determineSeverity($alertName)
        ];

        $this->activeAlerts[$alertName] = $alert;

        $this->logger->warning("Alert triggered: {$alertName}", $alert);

        // Send notifications
        $this->notify($alert);
    }

    public function resolve(string $alertName): void
    {
        if (!isset($this->activeAlerts[$alertName])) {
            return;
        }

        $alert = $this->activeAlerts[$alertName];
        unset($this->activeAlerts[$alertName]);

        $this->logger->info("Alert resolved: {$alertName}", $alert);

        // Send resolution notification
        $this->notifyResolution($alert);
    }

    public function getActiveAlerts(): array
    {
        return $this->activeAlerts;
    }

    private function determineSeverity(string $alertName): string
    {
        $criticalAlerts = ['application_unhealthy', 'high_memory_usage', 'payment_failures'];
        $warningAlerts = ['slow_request', 'high_cpu_usage', 'queue_backlog'];

        if (in_array($alertName, $criticalAlerts)) {
            return 'critical';
        }

        if (in_array($alertName, $warningAlerts)) {
            return 'warning';
        }

        return 'info';
    }

    private function notify(array $alert): void
    {
        $channels = $this->getNotificationChannels($alert['severity']);

        foreach ($channels as $channel) {
            try {
                $this->notificationChannels[$channel]->send($alert);
            } catch (Exception $e) {
                $this->logger->error("Failed to send notification via {$channel}", [
                    'alert' => $alert['name'],
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    private function notifyResolution(array $alert): void
    {
        $channels = ['slack', 'email']; // Notify resolution to fewer channels

        foreach ($channels as $channel) {
            try {
                $this->notificationChannels[$channel]->sendResolution($alert);
            } catch (Exception $e) {
                $this->logger->error("Failed to send resolution notification via {$channel}", [
                    'alert' => $alert['name'],
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    private function getNotificationChannels(string $severity): array
    {
        switch ($severity) {
            case 'critical':
                return ['slack', 'email', 'sms', 'pagerduty'];
            case 'warning':
                return ['slack', 'email'];
            case 'info':
                return ['slack'];
            default:
                return ['slack'];
        }
    }
}

// Usage Example
$monitoring = new MonitoringSystem(
    new PrometheusMetricsCollector('http://prometheus-gateway:9091'),
    new Logger('monitoring'),
    new AlertManager(new Logger('alerts'))
);

// Middleware for HTTP request monitoring
class MonitoringMiddleware
{
    private MonitoringSystem $monitoring;

    public function __construct(MonitoringSystem $monitoring)
    {
        $this->monitoring = $monitoring;
    }

    public function handle(Request $request, callable $next): Response
    {
        $startTime = microtime(true);

        try {
            $response = $next($request);

            $duration = (microtime(true) - $startTime) * 1000; // Convert to milliseconds

            $this->monitoring->recordHttpRequest(
                $request->getMethod(),
                $request->getPath(),
                $duration,
                $response->getStatusCode()
            );

            return $response;

        } catch (Exception $e) {
            $duration = (microtime(true) - $startTime) * 1000;

            // Record failed request
            $this->monitoring->recordHttpRequest(
                $request->getMethod(),
                $request->getPath(),
                $duration,
                500
            );

            throw $e;
        }
    }
}

// Background monitoring task
class MonitoringTask
{
    private MonitoringSystem $monitoring;

    public function __construct(MonitoringSystem $monitoring)
    {
        $this->monitoring = $monitoring;
    }

    public function run(): void
    {
        while (true) {
            try {
                // Record system metrics
                $this->monitoring->recordSystemMetrics();

                // Check application health
                $health = $this->monitoring->checkApplicationHealth();

                if ($health['status'] !== 'healthy') {
                    error_log('Application health check failed: ' . json_encode($health));
                }

                // Record business metrics
                $this->recordBusinessMetrics();

            } catch (Exception $e) {
                error_log('Monitoring task error: ' . $e->getMessage());
            }

            // Run every 30 seconds
            sleep(30);
        }
    }

    private function recordBusinessMetrics(): void
    {
        // Example business metrics - in real app, these would come from actual business logic
        $this->monitoring->recordBusinessMetrics('user_registration', [
            'source' => 'web',
            'plan' => 'premium'
        ]);

        // Mock some activity
        if (rand(1, 100) > 95) { // 5% chance
            $this->monitoring->recordBusinessMetrics('payment_failed', [
                'reason' => 'insufficient_funds',
                'amount' => rand(10, 1000)
            ]);
        }
    }
}

// Initialize monitoring
$monitoringTask = new MonitoringTask($monitoring);

// Run monitoring in background (in production, use a proper process manager)
if (function_exists('pcntl_fork')) {
    $pid = pcntl_fork();

    if ($pid === 0) {
        // Child process - run monitoring
        $monitoringTask->run();
        exit(0);
    }
}

// Your application code here...
echo "Application started with comprehensive monitoring!\n";
                        </div>
                    </div>

                    <div class="question-card fade-in-up">
                        <div class="question-header">
                            <div class="question-number">13</div>
                            <h3 class="question-title">Team Leadership and Mentoring in PHP Development</h3>
                        </div>
                        <div class="question-meta">
                            <span class="question-badge">Leadership</span>
                            <span class="question-badge">Mentoring</span>
                            <span class="question-badge">Team Management</span>
                        </div>
                        <div class="question-content">
                            <p>Design leadership strategies for PHP development teams, including mentoring programs, code review processes, knowledge sharing, and team growth initiatives.</p>

                            <div class="highlight-box success">
                                <div class="highlight-header">
                                    <i class="fas fa-users highlight-icon"></i>
                                    <strong>Leadership Responsibilities:</strong>
                                </div>
                                <ul>
                                    <li><strong>Technical Direction:</strong> Set architectural vision and technical standards</li>
                                    <li><strong>Mentoring:</strong> Guide junior developers and foster growth</li>
                                    <li><strong>Code Quality:</strong> Establish and enforce coding standards</li>
                                    <li><strong>Team Culture:</strong> Build collaborative and innovative environment</li>
                                </ul>
                            </div>
                        </div>

                        <button class="code-toggle-btn">
                            <i class="fas fa-code"></i> View Team Leadership Framework
                        </button>

                        <div class="code-block" data-lang="php" data-title="Team Leadership and Mentoring Framework">
// Team Leadership and Mentoring Framework

interface MentoringProgramInterface
{
    public function assignMentor(Mentor $mentor, Mentee $mentee): void;
    public function trackProgress(Mentee $mentee): array;
    public function scheduleMentoringSession(Mentor $mentor, Mentee $mentee, DateTime $dateTime): void;
    public function getMentoringGoals(Mentee $mentee): array;
}

interface CodeReviewProcessInterface
{
    public function submitForReview(PullRequest $pr): void;
    public function assignReviewers(PullRequest $pr, array $reviewers): void;
    public function reviewPullRequest(PullRequest $pr, Reviewer $reviewer, Review $review): void;
    public function approvePullRequest(PullRequest $pr, Reviewer $reviewer): void;
    public function requestChanges(PullRequest $pr, Reviewer $reviewer, array $changes): void;
}

class LeadershipDashboard
{
    private TeamMetrics $teamMetrics;
    private MentoringProgram $mentoringProgram;
    private CodeReviewProcess $codeReviewProcess;
    private KnowledgeSharing $knowledgeSharing;
    private Logger $logger;

    public function __construct(
        TeamMetrics $teamMetrics,
        MentoringProgram $mentoringProgram,
        CodeReviewProcess $codeReviewProcess,
        KnowledgeSharing $knowledgeSharing,
        Logger $logger
    ) {
        $this->teamMetrics = $teamMetrics;
        $this->mentoringProgram = $mentoringProgram;
        $this->codeReviewProcess = $codeReviewProcess;
        $this->knowledgeSharing = $knowledgeSharing;
        $this->logger = $logger;
    }

    public function getTeamOverview(): array
    {
        return [
            'team_size' => $this->teamMetrics->getTeamSize(),
            'active_projects' => $this->teamMetrics->getActiveProjects(),
            'code_quality_score' => $this->teamMetrics->getCodeQualityScore(),
            'mentoring_pairs' => $this->mentoringProgram->getActiveMentoringPairs(),
            'pending_reviews' => $this->codeReviewProcess->getPendingReviewsCount(),
            'knowledge_sessions' => $this->knowledgeSharing->getUpcomingSessions()
        ];
    }

    public function getIndividualPerformance(string $developerId): array
    {
        return [
            'code_quality' => $this->teamMetrics->getDeveloperCodeQuality($developerId),
            'review_feedback' => $this->codeReviewProcess->getDeveloperReviewFeedback($developerId),
            'mentoring_status' => $this->mentoringProgram->getMenteeStatus($developerId),
            'knowledge_contribution' => $this->knowledgeSharing->getDeveloperContributions($developerId),
            'project_contribution' => $this->teamMetrics->getDeveloperProjectContributions($developerId),
            'growth_areas' => $this->identifyGrowthAreas($developerId)
        ];
    }

    public function generateLeadershipReport(): LeadershipReport
    {
        $report = new LeadershipReport();

        $report->teamMetrics = $this->teamMetrics->getAllMetrics();
        $report->mentoringEffectiveness = $this->mentoringProgram->getEffectivenessMetrics();
        $report->codeReviewEfficiency = $this->codeReviewProcess->getEfficiencyMetrics();
        $report->knowledgeSharingImpact = $this->knowledgeSharing->getImpactMetrics();

        $report->recommendations = $this->generateRecommendations($report);

        return $report;
    }

    private function identifyGrowthAreas(string $developerId): array
    {
        $growthAreas = [];

        $codeQuality = $this->teamMetrics->getDeveloperCodeQuality($developerId);
        if ($codeQuality < 70) {
            $growthAreas[] = [
                'area' => 'Code Quality',
                'current_score' => $codeQuality,
                'recommendations' => [
                    'Complete advanced PHP training',
                    'Focus on SOLID principles',
                    'Improve test coverage'
                ]
            ];
        }

        $reviewFeedback = $this->codeReviewProcess->getDeveloperReviewFeedback($developerId);
        if ($reviewFeedback['avg_rating'] < 3.5) {
            $growthAreas[] = [
                'area' => 'Code Review Skills',
                'current_score' => $reviewFeedback['avg_rating'],
                'recommendations' => [
                    'Study design patterns',
                    'Learn advanced PHP features',
                    'Practice peer code reviews'
                ]
            ];
        }

        return $growthAreas;
    }

    private function generateRecommendations(LeadershipReport $report): array
    {
        $recommendations = [];

        if ($report->codeReviewEfficiency['avg_review_time'] > 4) { // Hours
            $recommendations[] = 'Implement automated code quality checks to reduce review time';
        }

        if ($report->mentoringEffectiveness['completion_rate'] < 70) {
            $recommendations[] = 'Enhance mentoring program structure and provide better mentor training';
        }

        if ($report->teamMetrics['code_quality_score'] < 75) {
            $recommendations[] = 'Establish coding standards and provide regular training sessions';
        }

        return $recommendations;
    }
}

class MentoringProgram implements MentoringProgramInterface
{
    private array $mentoringPairs = [];
    private array $mentoringGoals = [];
    private NotificationService $notifications;
    private Database $db;

    public function assignMentor(Mentor $mentor, Mentee $mentee): void
    {
        $pairId = uniqid('mentor_');

        $this->mentoringPairs[$pairId] = [
            'mentor' => $mentor,
            'mentee' => $mentee,
            'start_date' => new DateTime(),
            'goals' => [],
            'sessions' => [],
            'status' => 'active'
        ];

        // Set default goals
        $this->setDefaultGoals($mentee, $pairId);

        // Notify participants
        $this->notifications->send($mentor->getId(), 'You have been assigned as a mentor');
        $this->notifications->send($mentee->getId(), 'You have been assigned a mentor');

        $this->db->save('mentoring_pairs', $this->mentoringPairs[$pairId]);
    }

    public function trackProgress(Mentee $mentee): array
    {
        $pair = $this->findMentoringPairByMentee($mentee);

        if (!$pair) {
            return ['error' => 'No mentoring relationship found'];
        }

        $progress = [
            'goals_achieved' => 0,
            'total_goals' => count($pair['goals']),
            'sessions_completed' => count($pair['sessions']),
            'average_rating' => $this->calculateAverageRating($pair['sessions']),
            'time_spent' => $this->calculateTotalTimeSpent($pair['sessions'])
        ];

        foreach ($pair['goals'] as $goal) {
            if ($goal['status'] === 'completed') {
                $progress['goals_achieved']++;
            }
        }

        return $progress;
    }

    public function scheduleMentoringSession(Mentor $mentor, Mentee $mentee, DateTime $dateTime): void
    {
        $pair = $this->findMentoringPairByMentee($mentee);

        if (!$pair || $pair['mentor']->getId() !== $mentor->getId()) {
            throw new Exception('Invalid mentoring relationship');
        }

        $session = [
            'id' => uniqid('session_'),
            'scheduled_at' => $dateTime,
            'status' => 'scheduled',
            'topics' => [],
            'notes' => '',
            'rating' => null
        ];

        $pair['sessions'][] = $session;

        // Send calendar invites
        $this->sendCalendarInvites($pair, $session);

        $this->db->update('mentoring_pairs', $pair);
    }

    public function getMentoringGoals(Mentee $mentee): array
    {
        $pair = $this->findMentoringPairByMentee($mentee);
        return $pair ? $pair['goals'] : [];
    }

    public function getActiveMentoringPairs(): int
    {
        return count(array_filter($this->mentoringPairs, fn($pair) => $pair['status'] === 'active'));
    }

    public function getEffectivenessMetrics(): array
    {
        $totalPairs = count($this->mentoringPairs);
        $completedPairs = count(array_filter($this->mentoringPairs, fn($pair) => $pair['status'] === 'completed'));

        return [
            'total_pairs' => $totalPairs,
            'active_pairs' => $this->getActiveMentoringPairs(),
            'completion_rate' => $totalPairs > 0 ? ($completedPairs / $totalPairs) * 100 : 0,
            'average_sessions_per_pair' => $this->calculateAverageSessions(),
            'mentee_satisfaction' => $this->calculateMenteeSatisfaction()
        ];
    }

    private function setDefaultGoals(Mentee $mentee, string $pairId): void
    {
        $goals = [
            [
                'id' => uniqid('goal_'),
                'title' => 'Learn SOLID Principles',
                'description' => 'Understand and apply SOLID design principles',
                'status' => 'pending',
                'deadline' => (new DateTime())->modify('+30 days')
            ],
            [
                'id' => uniqid('goal_'),
                'title' => 'Master Unit Testing',
                'description' => 'Write comprehensive unit tests for PHP code',
                'status' => 'pending',
                'deadline' => (new DateTime())->modify('+45 days')
            ],
            [
                'id' => uniqid('goal_'),
                'title' => 'Database Optimization',
                'description' => 'Learn query optimization and indexing strategies',
                'status' => 'pending',
                'deadline' => (new DateTime())->modify('+60 days')
            ]
        ];

        $this->mentoringPairs[$pairId]['goals'] = $goals;
    }

    private function findMentoringPairByMentee(Mentee $mentee): ?array
    {
        foreach ($this->mentoringPairs as $pair) {
            if ($pair['mentee']->getId() === $mentee->getId() && $pair['status'] === 'active') {
                return $pair;
            }
        }

        return null;
    }

    private function calculateAverageRating(array $sessions): float
    {
        $ratings = array_filter(array_column($sessions, 'rating'));
        return !empty($ratings) ? array_sum($ratings) / count($ratings) : 0;
    }

    private function calculateTotalTimeSpent(array $sessions): int
    {
        $totalMinutes = 0;

        foreach ($sessions as $session) {
            if (isset($session['duration_minutes'])) {
                $totalMinutes += $session['duration_minutes'];
            }
        }

        return $totalMinutes;
    }

    private function calculateAverageSessions(): float
    {
        if (empty($this->mentoringPairs)) {
            return 0;
        }

        $totalSessions = array_sum(array_map(fn($pair) => count($pair['sessions']), $this->mentoringPairs));
        return $totalSessions / count($this->mentoringPairs);
    }

    private function calculateMenteeSatisfaction(): float
    {
        $allRatings = [];

        foreach ($this->mentoringPairs as $pair) {
            foreach ($pair['sessions'] as $session) {
                if (isset($session['rating'])) {
                    $allRatings[] = $session['rating'];
                }
            }
        }

        return !empty($allRatings) ? array_sum($allRatings) / count($allRatings) : 0;
    }

    private function sendCalendarInvites(array $pair, array $session): void
    {
        // Integration with calendar systems (Google Calendar, Outlook, etc.)
        // This would send calendar invites to both mentor and mentee
    }
}

class CodeReviewProcess implements CodeReviewProcessInterface
{
    private array $pullRequests = [];
    private array $reviewTemplates = [];
    private NotificationService $notifications;
    private CodeQualityChecker $qualityChecker;

    public function __construct(NotificationService $notifications, CodeQualityChecker $qualityChecker)
    {
        $this->notifications = $notifications;
        $this->qualityChecker = $qualityChecker;
        $this->setupReviewTemplates();
    }

    public function submitForReview(PullRequest $pr): void
    {
        $pr->status = 'pending_review';
        $pr->submittedAt = new DateTime();
        $pr->reviews = [];
        $pr->qualityScore = $this->qualityChecker->checkQuality($pr->files);

        $this->pullRequests[$pr->id] = $pr;

        // Auto-assign reviewers based on expertise
        $suggestedReviewers = $this->suggestReviewers($pr);
        $this->assignReviewers($pr, $suggestedReviewers);

        // Notify reviewers
        foreach ($suggestedReviewers as $reviewer) {
            $this->notifications->send(
                $reviewer->getId(),
                "New pull request requires your review: {$pr->title}"
            );
        }
    }

    public function assignReviewers(PullRequest $pr, array $reviewers): void
    {
        $pr->assignedReviewers = $reviewers;

        foreach ($reviewers as $reviewer) {
            $this->notifications->send(
                $reviewer->getId(),
                "You have been assigned to review: {$pr->title}"
            );
        }
    }

    public function reviewPullRequest(PullRequest $pr, Reviewer $reviewer, Review $review): void
    {
        $review->reviewerId = $reviewer->getId();
        $review->reviewedAt = new DateTime();
        $review->status = 'completed';

        $pr->reviews[] = $review;

        // Update PR status based on review
        $this->updatePullRequestStatus($pr);

        // Notify author
        $this->notifications->send(
            $pr->authorId,
            "Your pull request has been reviewed: {$pr->title}"
        );
    }

    public function approvePullRequest(PullRequest $pr, Reviewer $reviewer): void
    {
        $approval = new Review();
        $approval->type = 'approval';
        $approval->comments = 'Approved';
        $approval->reviewerId = $reviewer->getId();
        $approval->reviewedAt = new DateTime();

        $pr->reviews[] = $approval;
        $this->updatePullRequestStatus($pr);

        $this->notifications->send(
            $pr->authorId,
            "Your pull request has been approved: {$pr->title}"
        );
    }

    public function requestChanges(PullRequest $pr, Reviewer $reviewer, array $changes): void
    {
        $review = new Review();
        $review->type = 'changes_requested';
        $review->comments = implode("\n", $changes);
        $review->reviewerId = $reviewer->getId();
        $review->reviewedAt = new DateTime();
        $review->requestedChanges = $changes;

        $pr->reviews[] = $review;
        $this->updatePullRequestStatus($pr);

        $this->notifications->send(
            $pr->authorId,
            "Changes requested for your pull request: {$pr->title}"
        );
    }

    public function getPendingReviewsCount(): int
    {
        return count(array_filter($this->pullRequests, fn($pr) => $pr->status === 'pending_review'));
    }

    public function getEfficiencyMetrics(): array
    {
        $completedReviews = array_filter($this->pullRequests, fn($pr) => !empty($pr->reviews));

        $totalReviewTime = 0;
        $totalReviews = 0;

        foreach ($completedReviews as $pr) {
            foreach ($pr->reviews as $review) {
                if (isset($review->timeSpent)) {
                    $totalReviewTime += $review->timeSpent;
                    $totalReviews++;
                }
            }
        }

        return [
            'total_reviews' => count($completedReviews),
            'avg_review_time' => $totalReviews > 0 ? $totalReviewTime / $totalReviews : 0,
            'avg_reviews_per_pr' => count($completedReviews) > 0 ?
                array_sum(array_map(fn($pr) => count($pr->reviews), $completedReviews)) / count($completedReviews) : 0
        ];
    }

    private function setupReviewTemplates(): void
    {
        $this->reviewTemplates = [
            'security' => [
                'SQL Injection vulnerabilities',
                'XSS prevention',
                'Input validation',
                'Authentication bypass',
                'Authorization checks'
            ],
            'performance' => [
                'Database query optimization',
                'Memory usage',
                'Caching strategy',
                'Algorithm complexity',
                'Resource leaks'
            ],
            'architecture' => [
                'SOLID principles compliance',
                'Design pattern usage',
                'Separation of concerns',
                'Dependency injection',
                'Code reusability'
            ],
            'code_quality' => [
                'Code style consistency',
                'Documentation',
                'Test coverage',
                'Error handling',
                'Type safety'
            ]
        ];
    }

    private function suggestReviewers(PullRequest $pr): array
    {
        // Analyze code changes to suggest appropriate reviewers
        $areas = $this->analyzeCodeChanges($pr->files);

        $suggestedReviewers = [];

        foreach ($areas as $area) {
            $experts = $this->findExpertsInArea($area);
            $suggestedReviewers = array_merge($suggestedReviewers, array_slice($experts, 0, 2));
        }

        // Remove duplicates and limit to 3 reviewers
        $suggestedReviewers = array_unique($suggestedReviewers);
        return array_slice($suggestedReviewers, 0, 3);
    }

    private function analyzeCodeChanges(array $files): array
    {
        $areas = [];

        foreach ($files as $file) {
            if (preg_match('/security|auth|login/i', $file)) {
                $areas[] = 'security';
            }
            if (preg_match('/database|query|model/i', $file)) {
                $areas[] = 'database';
            }
            if (preg_match('/controller|service/i', $file)) {
                $areas[] = 'architecture';
            }
        }

        return array_unique($areas);
    }

    private function findExpertsInArea(string $area): array
    {
        // In a real system, this would query a database of developer expertise
        // For now, return mock reviewers
        return [
            new Reviewer('alice', 'Alice Johnson'),
            new Reviewer('bob', 'Bob Smith'),
            new Reviewer('carol', 'Carol Williams')
        ];
    }

    private function updatePullRequestStatus(PullRequest $pr): void
    {
        $approvals = array_filter($pr->reviews, fn($review) => $review->type === 'approval');
        $changeRequests = array_filter($pr->reviews, fn($review) => $review->type === 'changes_requested');

        if (count($approvals) >= 2) {
            $pr->status = 'approved';
        } elseif (!empty($changeRequests)) {
            $pr->status = 'changes_requested';
        }
    }
}

class KnowledgeSharing
{
    private array $sessions = [];
    private array $resources = [];
    private NotificationService $notifications;

    public function scheduleSession(string $title, string $presenter, DateTime $dateTime, array $topics): void
    {
        $session = [
            'id' => uniqid('session_'),
            'title' => $title,
            'presenter' => $presenter,
            'scheduled_at' => $dateTime,
            'topics' => $topics,
            'attendees' => [],
            'status' => 'scheduled'
        ];

        $this->sessions[$session['id']] = $session;

        // Notify team about new session
        $this->notifications->sendToAll(
            "New knowledge sharing session: {$title} by {$presenter}"
        );
    }

    public function registerForSession(string $sessionId, string $attendeeId): void
    {
        if (!isset($this->sessions[$sessionId])) {
            throw new Exception('Session not found');
        }

        $this->sessions[$sessionId]['attendees'][] = $attendeeId;
    }

    public function addResource(string $title, string $type, string $url, array $tags): void
    {
        $resource = [
            'id' => uniqid('resource_'),
            'title' => $title,
            'type' => $type, // 'article', 'video', 'book', 'presentation'
            'url' => $url,
            'tags' => $tags,
            'added_by' => 'current_user', // Would be dynamic
            'added_at' => new DateTime(),
            'views' => 0,
            'rating' => 0
        ];

        $this->resources[$resource['id']] = $resource;
    }

    public function getUpcomingSessions(): array
    {
        $now = new DateTime();
        $upcoming = array_filter($this->sessions, function($session) use ($now) {
            return $session['scheduled_at'] > $now && $session['status'] === 'scheduled';
        });

        usort($upcoming, fn($a, $b) => $a['scheduled_at'] <=> $b['scheduled_at']);

        return array_slice($upcoming, 0, 5);
    }

    public function getDeveloperContributions(string $developerId): array
    {
        $contributions = [
            'sessions_presented' => count(array_filter($this->sessions, fn($s) => $s['presenter_id'] === $developerId)),
            'resources_added' => count(array_filter($this->resources, fn($r) => $r['added_by'] === $developerId)),
            'sessions_attended' => 0 // Would need attendance tracking
        ];

        return $contributions;
    }

    public function getImpactMetrics(): array
    {
        return [
            'total_sessions' => count($this->sessions),
            'total_resources' => count($this->resources),
            'avg_attendance' => $this->calculateAverageAttendance(),
            'popular_topics' => $this->getPopularTopics()
        ];
    }

    private function calculateAverageAttendance(): float
    {
        if (empty($this->sessions)) return 0;

        $totalAttendance = array_sum(array_map(fn($s) => count($s['attendees']), $this->sessions));
        return $totalAttendance / count($this->sessions);
    }

    private function getPopularTopics(): array
    {
        $topicCount = [];

        foreach ($this->sessions as $session) {
            foreach ($session['topics'] as $topic) {
                $topicCount[$topic] = ($topicCount[$topic] ?? 0) + 1;
            }
        }

        arsort($topicCount);
        return array_slice($topicCount, 0, 5, true);
    }
}

// Usage Example
$leadershipDashboard = new LeadershipDashboard(
    new TeamMetrics(),
    new MentoringProgram(new NotificationService(), new Database()),
    new CodeReviewProcess(new NotificationService(), new CodeQualityChecker()),
    new KnowledgeSharing(new NotificationService()),
    new Logger('leadership')
);

// Schedule a mentoring session
$mentor = new Mentor('john_doe', 'John Doe');
$mentee = new Mentee('jane_smith', 'Jane Smith');

$mentoringProgram = $leadershipDashboard->mentoringProgram;
$mentoringProgram->assignMentor($mentor, $mentee);
$mentoringProgram->scheduleMentoringSession($mentor, $mentee, new DateTime('+1 week'));

// Schedule knowledge sharing session
$knowledgeSharing = $leadershipDashboard->knowledgeSharing;
$knowledgeSharing->scheduleSession(
    'Advanced PHP Design Patterns',
    'Senior Architect',
    new DateTime('+2 weeks'),
    ['design-patterns', 'php', 'architecture']
);

// Get team overview
$overview = $leadershipDashboard->getTeamOverview();
echo "Team Overview:\n";
echo "- Team Size: {$overview['team_size']}\n";
echo "- Active Projects: {$overview['active_projects']}\n";
echo "- Mentoring Pairs: {$overview['mentoring_pairs']}\n";

// Generate leadership report
$report = $leadershipDashboard->generateLeadershipReport();
echo "\nLeadership Report Generated with " . count($report->recommendations) . " recommendations\n";
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js"></script>
    <script src="scripts.js"></script>
</body>
</html>
